import{_ as o,C as h,c as p,o as a,a3 as i,b as e,w as s,a as l,G as r,a4 as d}from"./chunks/framework.CUcrqFol.js";const m=JSON.parse('{"title":"3.2 像搭乐高一样构建页面——前端构建块：组件/状态/路由/数据获取/错误与空态","description":"3.2 像搭乐高一样构建页面——前端构建块 一句话破题 组件是 React 应用的原子单位，通过 Props 传递数据、State 管理内部状态、Effects 处理副作用。 本节定位 如果说路由是网站的骨架，那么组件就是构成骨架的每一块积木。本节将教你如何像搭乐高一样，用可复用的组件构建复杂的用户界面。 组件化思维的","frontmatter":{"title":"3.2 像搭乐高一样构建页面——前端构建块：组件/状态/路由/数据获取/错误与空态","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/03-frontend/3.2-components/index.md","filePath":"Advanced-old/03-frontend/3.2-components/index.md","lastUpdated":1766168364000}'),k={name:"Advanced-old/03-frontend/3.2-components/index.md"};function E(c,t,g,A,B,u){const n=h("Mermaid");return a(),p("div",null,[t[2]||(t[2]=i('<h1 id="_3-2-像搭乐高一样构建页面——前端构建块" tabindex="-1">3.2 像搭乐高一样构建页面——前端构建块 <a class="header-anchor" href="#_3-2-像搭乐高一样构建页面——前端构建块" aria-label="Permalink to &quot;3.2 像搭乐高一样构建页面——前端构建块&quot;">​</a></h1><h3 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h3><p>组件是 React 应用的原子单位，通过 Props 传递数据、State 管理内部状态、Effects 处理副作用。</p><h3 id="本节定位" tabindex="-1">本节定位 <a class="header-anchor" href="#本节定位" aria-label="Permalink to &quot;本节定位&quot;">​</a></h3><p>如果说路由是网站的骨架，那么组件就是构成骨架的每一块积木。本节将教你如何像搭乐高一样，用可复用的组件构建复杂的用户界面。</p>',5)),(a(),e(d,null,{default:s(()=>[r(n,{id:"mermaid-15",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A%5B%22%E9%A1%B5%E9%9D%A2%20Page%22%5D%20--%3E%20B%5B%22%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6%22%5D%0A%20%20%20%20B%20--%3E%20C%5B%22%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%22%5D%0A%20%20%20%20C%20--%3E%20D%5B%22%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6%22%5D%0A%20%20%20%20D%20--%3E%20E%5B%22%E5%8E%9F%E5%AD%90%E7%BB%84%E4%BB%B6%22%5D%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%23f9f%2Cstroke%3A%23333%0A%20%20%20%20style%20E%20fill%3A%239f9%2Cstroke%3A%23333%0A"})]),fallback:s(()=>[...t[0]||(t[0]=[l(" Loading... ",-1)])]),_:1})),t[3]||(t[3]=i('<h3 id="组件化思维的核心" tabindex="-1">组件化思维的核心 <a class="header-anchor" href="#组件化思维的核心" aria-label="Permalink to &quot;组件化思维的核心&quot;">​</a></h3><h4 id="为什么要组件化" tabindex="-1">为什么要组件化？ <a class="header-anchor" href="#为什么要组件化" aria-label="Permalink to &quot;为什么要组件化？&quot;">​</a></h4><table tabindex="0"><thead><tr><th>传统开发</th><th>组件化开发</th></tr></thead><tbody><tr><td>一个页面一坨代码</td><td>拆分成可复用的小块</td></tr><tr><td>改一处影响全局</td><td>组件内部独立运作</td></tr><tr><td>复制粘贴满天飞</td><td>一处修改，处处生效</td></tr><tr><td>难以测试</td><td>单元测试友好</td></tr></tbody></table><h4 id="组件的三大要素" tabindex="-1">组件的三大要素 <a class="header-anchor" href="#组件的三大要素" aria-label="Permalink to &quot;组件的三大要素&quot;">​</a></h4><ol><li><strong>Props（属性）</strong>：父组件传递给子组件的数据，只读</li><li><strong>State（状态）</strong>：组件内部管理的数据，可变</li><li><strong>Effects（副作用）</strong>：与外部世界交互的逻辑</li></ol>',5)),(a(),e(d,null,{default:s(()=>[r(n,{id:"mermaid-88",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20A%5B%22%E7%88%B6%E7%BB%84%E4%BB%B6%22%5D%20--%3E%7C%22Props%22%7C%20B%5B%22%E5%AD%90%E7%BB%84%E4%BB%B6%22%5D%0A%20%20%20%20B%20--%3E%7C%22%E5%86%85%E9%83%A8%E7%AE%A1%E7%90%86%22%7C%20C%5B%22State%22%5D%0A%20%20%20%20B%20--%3E%7C%22%E5%89%AF%E4%BD%9C%E7%94%A8%22%7C%20D%5B%22Effects%22%5D%0A%20%20%20%20D%20--%3E%20E%5B%22API%2FDOM%2F%E5%AE%9A%E6%97%B6%E5%99%A8%22%5D%0A"})]),fallback:s(()=>[...t[1]||(t[1]=[l(" Loading... ",-1)])]),_:1})),t[4]||(t[4]=i(`<h3 id="server-component-vs-client-component" tabindex="-1">Server Component vs Client Component <a class="header-anchor" href="#server-component-vs-client-component" aria-label="Permalink to &quot;Server Component vs Client Component&quot;">​</a></h3><p>在 App Router 中，组件默认是 Server Component：</p><table tabindex="0"><thead><tr><th>特性</th><th>Server Component</th><th>Client Component</th></tr></thead><tbody><tr><td>默认值</td><td>是</td><td>否（需 <code>&#39;use client&#39;</code>）</td></tr><tr><td>可使用 Hooks</td><td>否</td><td>是</td></tr><tr><td>可访问浏览器 API</td><td>否</td><td>是</td></tr><tr><td>可直接访问数据库</td><td>是</td><td>否</td></tr><tr><td>打包到客户端 JS</td><td>否</td><td>是</td></tr><tr><td>适用场景</td><td>数据获取、静态 UI</td><td>交互、状态管理</td></tr></tbody></table><p><strong>何时使用 Client Component：</strong></p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;use client&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 在文件顶部声明</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      点击次数：{count}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="组件设计原则" tabindex="-1">组件设计原则 <a class="header-anchor" href="#组件设计原则" aria-label="Permalink to &quot;组件设计原则&quot;">​</a></h3><ol><li><strong>单一职责</strong>：每个组件只做一件事</li><li><strong>Props 向下，Events 向上</strong>：数据单向流动</li><li><strong>组合优于继承</strong>：通过嵌套组合构建复杂 UI</li><li><strong>关注点分离</strong>：展示逻辑与业务逻辑分开</li></ol><h3 id="本节导航" tabindex="-1">本节导航 <a class="header-anchor" href="#本节导航" aria-label="Permalink to &quot;本节导航&quot;">​</a></h3><table tabindex="0"><thead><tr><th>小节</th><th>主题</th><th>核心内容</th></tr></thead><tbody><tr><td><strong>3.2.1</strong></td><td>Props</td><td>类型定义、默认值、children</td></tr><tr><td><strong>3.2.2</strong></td><td>State</td><td>useState、状态提升</td></tr><tr><td><strong>3.2.3</strong></td><td>全局状态</td><td>Context、Zustand/Jotai</td></tr><tr><td><strong>3.2.4</strong></td><td>Effects</td><td>useEffect、清理函数</td></tr><tr><td><strong>3.2.5</strong></td><td>自定义 Hooks</td><td>逻辑复用与抽象</td></tr><tr><td><strong>3.2.6</strong></td><td>组件设计</td><td>单一职责、组合模式</td></tr></tbody></table><h3 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h3><p><strong>核心意图</strong>：让 AI 帮你设计和实现可复用的组件。</p><p><strong>需求定义公式</strong>：</p><ul><li>功能描述：我需要一个 [组件名称]，用于 [具体用途]</li><li>交互方式：用户可以 [操作描述]</li><li>预期效果：组件展示 [外观描述]，响应 [交互行为]</li></ul><p><strong>关键术语</strong>：<code>Props</code>、<code>State</code>、<code>useEffect</code>、<code>&#39;use client&#39;</code>、<code>Server Component</code></p><p><strong>交互策略</strong>：</p><ol><li>先让 AI 分析组件应该是 Server 还是 Client</li><li>定义 Props 接口</li><li>实现基础 UI 结构</li><li>添加交互逻辑和状态管理</li></ol><h3 id="验收清单" tabindex="-1">验收清单 <a class="header-anchor" href="#验收清单" aria-label="Permalink to &quot;验收清单&quot;">​</a></h3><ul><li>[ ] 理解 Server/Client Component 的区别</li><li>[ ] 知道何时使用 <code>&#39;use client&#39;</code></li><li>[ ] 能够设计合理的 Props 接口</li><li>[ ] 理解数据流动方向（Props 向下，Events 向上）</li></ul>`,18))])}const y=o(k,[["render",E]]);export{m as __pageData,y as default};
