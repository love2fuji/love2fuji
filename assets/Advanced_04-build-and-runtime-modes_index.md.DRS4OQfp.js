import{_ as o,c as d,o as t,a3 as n}from"./chunks/framework.CUcrqFol.js";const m=JSON.parse('{"title":"第四章：代码运行的三种状态与构建原理","description":"第四章：代码运行的三种状态与构建原理 序言 文档备齐，你正式开始开发。AI 帮你生成了新的代码文件。你切换到浏览器，疯狂刷新，但页面纹丝不动。你开始怀疑 AI 在骗你，或者电脑坏了。直到十分钟后，老师傅路过，指着你编辑器标签页上那个不起眼的**白色圆点**说：“你没保存文件。”那一刻，你学会了肌肉记忆般的 （当然，后来","frontmatter":{"title":"第四章：代码运行的三种状态与构建原理"},"headers":[],"relativePath":"Advanced/04-build-and-runtime-modes/index.md","filePath":"Advanced/04-build-and-runtime-modes/index.md","lastUpdated":1766168364000}'),s={name:"Advanced/04-build-and-runtime-modes/index.md"};function c(r,e,p,a,i,g){return t(),d("div",null,[...e[0]||(e[0]=[n('<h1 id="第四章-代码运行的三种状态与构建原理" tabindex="-1">第四章：代码运行的三种状态与构建原理 <a class="header-anchor" href="#第四章-代码运行的三种状态与构建原理" aria-label="Permalink to &quot;第四章：代码运行的三种状态与构建原理&quot;">​</a></h1><h2 id="序言" tabindex="-1">序言 <a class="header-anchor" href="#序言" aria-label="Permalink to &quot;序言&quot;">​</a></h2><p>文档备齐，你正式开始开发。AI 帮你生成了新的代码文件。你切换到浏览器，疯狂刷新，但页面纹丝不动。你开始怀疑 AI 在骗你，或者电脑坏了。直到十分钟后，老师傅路过，指着你编辑器标签页上那个不起眼的<strong>白色圆点</strong>说：“你没保存文件。”那一刻，你学会了肌肉记忆般的 <code>Ctrl+S</code>（当然，后来你在 IDE 里开启了自动保存，彻底告别了这个烦恼）。</p><p>随着开发的深入，老师傅特意给你科普了代码的<strong>三种生命状态</strong>，以避免你混淆。</p><p>首先是 <strong>Dev（开发模式）</strong>，就是你平时用的 <code>pnpm dev</code>。它就像是<strong>打草稿</strong>。在这个模式下，当你修改代码并保存后，浏览器<strong>不需要</strong>刷新整个页面，只会替换改动的那一小块组件。这意味着如果你正在填写一个长长的表单，改了样式后，表单里填好的内容<strong>不会丢失</strong>。但代价是运行速度较慢，且包含了大量用于报错的调试信息。</p><p>其次是 <strong>Build（构建模式）</strong>，当你准备上线时，需要运行 <code>pnpm build</code>。这个过程就像是<strong>把草稿排版印刷成书</strong>。它会把你写的所有 TypeScript、React 代码进行压缩、优化、翻译，最终在项目中生成一个 <code>.next</code>（或 <code>dist</code>）文件夹。这里面的代码体积极小、运行极快，是专门给用户看的正式版。</p><p>最后是 <strong>Preview（预览模式）</strong>，运行 <code>pnpm preview</code> 或 <code>pnpm start</code>。这是在本地<strong>模拟正式上线的环境</strong>，用来运行刚才 <code>build</code> 生成的“正式版”。通常在上线前，你会用这个模式最后检查一遍有没有 Bug。</p><p>这时候，你可能会疑惑：<strong>为什么输入 <code>pnpm dev</code> 就能启动项目？</strong> 老师傅让你打开根目录下的 <strong><code>package.json</code></strong> 文件。他告诉你，这是 Node.js 项目的<strong>核心配置文件</strong>，管理着项目的元数据、脚本和依赖。</p><ul><li><strong>脚本管理 (Scripts)</strong>：在 <code>scripts</code> 字段中，定义了项目常用的运行命令。当你在终端输入 <code>pnpm dev</code> 时，包管理器会查表，发现它对应的是 <code>next dev</code> 命令并执行它。这就是为什么复杂的底层命令可以被简化成短短的 <code>dev</code> 或 <code>build</code>。<strong>老师傅顺便提了一嘴，这里也是自定义“房间号”的地方。</strong> 还记得第一章那个烦人的端口占用吗？你完全可以在这里把命令修改为 <code>next dev -p 4000</code>。这样，下次你运行 <code>pnpm dev</code> 时，应用就会直接在 4000 端口启动，彻底避开拥挤的 3000 端口。</li><li><strong>依赖管理 (Dependencies)</strong>：<code>dependencies</code> 列表明确记录了项目运行所必须安装的第三方库（如 React, Next.js, Prisma）及其具体版本号。这确保了其他人（或服务器）获取代码后，可以通过 <code>pnpm install</code> 安装一模一样的库，完美还原你的开发环境。</li></ul><p>构建完成后，你试图在文件夹里找一个 <code>index.html</code> 双击打开，就像第一章做的那样。老师傅告诉你构建产物在 <code>.next</code>（或者 <code>dist</code>）文件夹，但你翻遍了 <code>.next</code> 文件夹，只看到了一堆乱码般的 <code>.js</code> 和 <code>.json</code> 文件。老师傅告诉你，<strong>本教程使用的 Next.js 全栈框架，本质上是一个运行在 Node.js 上的“程序”，而不是简单的“文件”</strong>。它需要连接数据库、处理 API 请求、在服务端渲染页面，这些都离不开<strong>服务器环境</strong>的支持。</p><p>当然，有些场景下你也可以开发<strong>纯静态项目</strong>（比如使用 Vite + Vue/React），这种项目打包后确实会在 <code>dist</code> 文件夹生成一个 <code>index.html</code>。但为了带你走完数据库、鉴权等完整的全栈流程，我们选择了 Next.js。不过要记住，即使是 Vite 打包出的纯静态文件，通常也不能直接双击打开。因为现代应用使用<strong>绝对路径</strong>（如 <code>/assets/app.js</code>）引用资源，而双击打开使用的是 <strong>文件协议</strong>（<code>file:///</code>），这会导致浏览器找不到资源。</p><p>所以，请记住：<strong>永远不要直接双击打开构建后的代码文件，永远通过 Web 服务器（如 <code>pnpm start</code> 或 <code>pnpm preview</code>）来访问你的应用。</strong></p><p>除了忘记保存文件，还有一个常见原因会让你的页面纹丝不动，那就是<strong>浏览器缓存</strong>。假设有一次，你让 AI 把按钮从蓝色改成红色。代码改了，文件保存了，编译也成功了，但你刷新浏览器，按钮依然是蓝色的。你崩溃了，以为进入了平行宇宙。后来才知道，浏览器为了加载更快，自作聪明地把旧的 CSS 文件存了起来。你学会了两个大招：一是<strong>强制刷新</strong>（按住 <code>Shift</code> + <code>Ctrl</code> + <code>R</code>）；二是打开 F12 开发者工具，在 Network 选项卡里勾选 <strong>&quot;Disable cache&quot;</strong>，只要开发者工具开着，浏览器就不敢偷懒。</p>',13)])])}const u=o(s,[["render",c]]);export{m as __pageData,u as default};
