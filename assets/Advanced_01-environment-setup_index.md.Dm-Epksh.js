import{_ as e,c as t,o as n,a3 as r}from"./chunks/framework.CUcrqFol.js";const m=JSON.parse('{"title":"第一章：环境搭建、代码形态与包管理器的选择","description":"第一章：环境搭建、代码形态与包管理器的选择 序言 你有一台新电脑，里面干干净净，除了浏览器什么都没有。你不会写代码，但是你觉得最近 AI 很火，心里有一个绝妙的 App 想法，打算在网页上指挥 AI 帮你做一个 Demo。 你遇到的第一个困惑是 **AI 输出代码的格式**。有时候，AI 会直接给你一段长长的代码，告诉","frontmatter":{"title":"第一章：环境搭建、代码形态与包管理器的选择"},"headers":[],"relativePath":"Advanced/01-environment-setup/index.md","filePath":"Advanced/01-environment-setup/index.md","lastUpdated":1766168364000}'),s={name:"Advanced/01-environment-setup/index.md"};function d(a,o,p,c,g,i){return n(),t("div",null,[...o[0]||(o[0]=[r('<h1 id="第一章-环境搭建、代码形态与包管理器的选择" tabindex="-1">第一章：环境搭建、代码形态与包管理器的选择 <a class="header-anchor" href="#第一章-环境搭建、代码形态与包管理器的选择" aria-label="Permalink to &quot;第一章：环境搭建、代码形态与包管理器的选择&quot;">​</a></h1><h2 id="序言" tabindex="-1">序言 <a class="header-anchor" href="#序言" aria-label="Permalink to &quot;序言&quot;">​</a></h2><p>你有一台新电脑，里面干干净净，除了浏览器什么都没有。你不会写代码，但是你觉得最近 AI 很火，心里有一个绝妙的 App 想法，打算在网页上指挥 AI 帮你做一个 Demo。</p><p>你遇到的第一个困惑是 <strong>AI 输出代码的格式</strong>。有时候，AI 会直接给你一段长长的代码，告诉你保存为 <code>index.html</code>。你照做了，新建文件、粘贴、保存，双击打开，浏览器里真的出现了一个会动的网页。你很高兴，以为编程不过如此。这种文件通常把结构（HTML）、样式（CSS）和逻辑（JavaScript）都塞在了一起，适合做简单的演示。</p><p>但当你要求更复杂的功能时，AI 开始给你后缀是 <code>.ts</code> 或 <code>.tsx</code> 的代码，还提到了 <code>import</code>、<code>React</code> 等词汇。你像之前一样保存文件，双击打开，却发现根本打不开，或者显示一堆看不懂的代码。你懵了，为什么代码不能跑了？</p><p>老师傅告诉你，这是因为现代开发使用了 <strong>TypeScript</strong>（简称 TS），它比普通的 JavaScript 更严谨，适合做大项目。但是，浏览器看不懂 TS，它需要一个“翻译官”把 TS 翻译成浏览器能懂的语言。这个翻译官运行在你的电脑上，它的名字叫 <strong>Node.js</strong>。如果不安装它，你的电脑就无法运行这些现代化的代码构建工具。</p><p>你兴致勃勃地去下载 Node.js，但老师傅和 Nodejs 官网一样，拦住了你。他推荐你安装 <strong>nvm</strong>（Node Version Manager）。因为 Node.js 经常更新，不同项目可能需要不同版本，nvm 让你能轻松切换版本，而不需要反复卸载重装。你通过 nvm 安装了最新的 LTS（长期支持）版本，并在老师傅的推荐下更换了<strong>国内镜像源</strong>（为了解决下载慢的问题），终于拥有了所谓的运行环境。</p><p>接着，你接触到了 <strong>Terminal（终端）</strong>（如 Windows 的 CMD、PowerShell 或 Mac 的 Terminal）。它不是什么神秘的黑客工具，而是一种直接通过文字指令与操作系统对话的方式。相比于用鼠标点击图标，终端能更精确、更快速地执行复杂的任务。</p><p>环境有了，老师傅告诉你，现代软件开发很少从零开始写起。就像盖房子不需要自己烧砖一样，你可以直接使用全世界程序员贡献的代码——也就是<strong>开源代码包</strong>。React 帮你搞定界面，Axios 帮你搞定网络请求，Day.js 帮你处理时间，Zod 帮你处理数据验证。这些现成的代码包能让你专注于业务逻辑，而不是重复造轮子。</p><p>那么，怎么安装别人写好的代码包呢？你需要一个<strong>包管理器</strong>。Node.js 自带了一个叫 <strong>npm</strong>，但它下载速度慢，而且会把你的硬盘塞满重复的文件。有人开发了 <strong>yarn</strong>，但现在更推荐 <strong>pnpm</strong>。老师傅告诉你，一开始就使用 <code>pnpm</code>，它下载速度极快，而且通过巧妙的链接技术节省大量的硬盘空间。你学会了配置 pnpm 的国内镜像源，彻底解决了下载卡顿的问题。</p><p>现在，你拥有了完整的现代化开发环境，可以处理任何 AI 生成的代码了。老师傅特意叮嘱：<strong>新建项目时，务必新建一个不含有中文、空格的文件夹</strong>。这是因为许多底层的开发工具对非英文字符支持不佳，中文路径往往是各种离奇报错的根源。</p><p>代码都在本地了，但你完全不知道怎么把它跑起来。你试探性地把文件发给 AI，问它：“我该怎么启动这个项目？”AI 告诉你，要先运行 <code>pnpm install</code> 安装依赖（把别人写好的积木搬回家），然后运行 <code>pnpm dev</code> 启动开发服务器。你照着敲了进去，屏幕上滚动了一堆看不懂的字符，最后停在了 <code>Ready in 2345ms</code>，下面还有一行绿色的字：<code>http://localhost:3000</code>。</p><p>你盯着这个地址，老师傅给你补了一课网络基础：<strong>Localhost</strong> 也就是 <strong>127.0.0.1</strong>，在网络世界里，这代表“你自己的电脑”。如果在互联网上，每个网站都有一个 IP 地址（如 <code>192.168.x.x</code>），那么 <code>127.0.0.1</code> 就是你电脑永远的“身份证号”，而 <code>localhost</code> 则是它的“名字”（域名）。</p><p>而在冒号后面的 <strong>:3000</strong> 则是<strong>端口号（Port）</strong>。如果把你的电脑比作一栋大楼，IP 是大楼的地址，那么端口就是具体的<strong>房间号</strong>。你的网页应用此刻正坐在 3000 号房间里，等待你的浏览器去敲门。</p><p>你激动地点开这个链接，网页真的出来了！不过，老师傅顺便提了一句，虽然现在的开发工具都很智能——如果你再开一个项目，它们通常会自动检测到 3000 房间有人了，然后自动顺延去 3001 房间——但在<strong>生产环境</strong>（也就是未来你要部署的服务器）里，规则是严苛的：<strong>一个房间（端口）同时只能容纳一个程序</strong>。如果你看到 <code>EADDRINUSE</code> 这样的红色报错，别慌，那只是意味着你想去的房间已经被占用了，通常让 AI 为你换一个启动的端口就行了。</p>',15)])])}const A=e(s,[["render",d]]);export{m as __pageData,A as default};
