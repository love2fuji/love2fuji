import{_ as o,C as i,c as n,o as a,a3 as e,b as d,w as r,a as s,G as h,a4 as u}from"./chunks/framework.CUcrqFol.js";const E=JSON.parse('{"title":"8.2 为什么不能随便提交代码——分支策略：Feature→Develop→Main；禁止直推 Main","description":"8.2 为什么不能随便提交代码——分支策略 直接往 main 分支提交代码，就像在高速公路上随意变道——看似方便，实则危险。 为什么需要分支策略 没有分支策略的团队常常遇到这些问题： 未经测试的代码直接上线，导致生产事故 多人同时开发，代码频繁冲突 出了问题不知道是哪次提交引入的 紧急 bug 修复被未完成的功能代码阻","frontmatter":{"title":"8.2 为什么不能随便提交代码——分支策略：Feature→Develop→Main；禁止直推 Main","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/08-workflow/8.2-branch-strategy/index.md","filePath":"Advanced-old/08-workflow/8.2-branch-strategy/index.md","lastUpdated":1766168364000}'),c={name:"Advanced-old/08-workflow/8.2-branch-strategy/index.md"};function b(g,t,p,_,A,m){const l=i("Mermaid");return a(),n("div",null,[t[1]||(t[1]=e('<h1 id="_8-2-为什么不能随便提交代码——分支策略" tabindex="-1">8.2 为什么不能随便提交代码——分支策略 <a class="header-anchor" href="#_8-2-为什么不能随便提交代码——分支策略" aria-label="Permalink to &quot;8.2 为什么不能随便提交代码——分支策略&quot;">​</a></h1><p>直接往 main 分支提交代码，就像在高速公路上随意变道——看似方便，实则危险。</p><h2 id="为什么需要分支策略" tabindex="-1">为什么需要分支策略 <a class="header-anchor" href="#为什么需要分支策略" aria-label="Permalink to &quot;为什么需要分支策略&quot;">​</a></h2><p>没有分支策略的团队常常遇到这些问题：</p><ul><li>未经测试的代码直接上线，导致生产事故</li><li>多人同时开发，代码频繁冲突</li><li>出了问题不知道是哪次提交引入的</li><li>紧急 bug 修复被未完成的功能代码阻塞</li></ul><p><strong>分支策略的本质是隔离风险</strong>——让不同阶段的代码在不同的&quot;车道&quot;上行驶。</p><h2 id="分支策略全景" tabindex="-1">分支策略全景 <a class="header-anchor" href="#分支策略全景" aria-label="Permalink to &quot;分支策略全景&quot;">​</a></h2>',7)),(a(),d(u,null,{default:r(()=>[h(l,{id:"mermaid-40",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20subgraph%20%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%0A%20%20%20%20%20%20%20%20F1%5Bfeat%2Flogin%5D%20--%3E%20D%5Bdevelop%5D%0A%20%20%20%20%20%20%20%20F2%5Bfeat%2Fprofile%5D%20--%3E%20D%0A%20%20%20%20%20%20%20%20F3%5Bfix%2Fbug-123%5D%20--%3E%20D%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20subgraph%20%E5%8F%91%E5%B8%83%E9%98%B6%E6%AE%B5%0A%20%20%20%20%20%20%20%20D%20--%3E%20R%5Brelease%2F1.0%5D%0A%20%20%20%20%20%20%20%20R%20--%3E%20M%5Bmain%5D%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20subgraph%20%E7%B4%A7%E6%80%A5%E4%BF%AE%E5%A4%8D%0A%20%20%20%20%20%20%20%20M%20--%3E%20H%5Bhotfix%2Fcritical%5D%0A%20%20%20%20%20%20%20%20H%20--%3E%20M%0A%20%20%20%20%20%20%20%20H%20--%3E%20D%0A%20%20%20%20end%0A"})]),fallback:r(()=>[...t[0]||(t[0]=[s(" Loading... ",-1)])]),_:1})),t[2]||(t[2]=e('<h2 id="两种主流分支模型" tabindex="-1">两种主流分支模型 <a class="header-anchor" href="#两种主流分支模型" aria-label="Permalink to &quot;两种主流分支模型&quot;">​</a></h2><table tabindex="0"><thead><tr><th>模型</th><th>适用场景</th><th>复杂度</th><th>分支数量</th></tr></thead><tbody><tr><td>Git Flow</td><td>传统软件、定期发布</td><td>高</td><td>多</td></tr><tr><td>GitHub Flow</td><td>持续部署、Web 应用</td><td>低</td><td>少</td></tr></tbody></table><p><strong>推荐</strong>：对于 Next.js 全栈项目，<strong>GitHub Flow</strong> 更为合适——简单、快速、适合持续部署。</p><h2 id="本节结构" tabindex="-1">本节结构 <a class="header-anchor" href="#本节结构" aria-label="Permalink to &quot;本节结构&quot;">​</a></h2><ol><li><strong>Git Flow</strong>：功能/发布/热修复分支的完整工作流</li><li><strong>GitHub Flow</strong>：适合小团队的简化分支模型</li><li><strong>分支保护</strong>：如何强制 PR 和状态检查</li><li><strong>代码审查</strong>：PR 模板和 Review 最佳实践</li></ol><h2 id="核心原则" tabindex="-1">核心原则 <a class="header-anchor" href="#核心原则" aria-label="Permalink to &quot;核心原则&quot;">​</a></h2><p>无论选择哪种模型，都应遵循以下原则：</p><ol><li><strong>main 分支始终可部署</strong>：main 上的代码随时可以上线</li><li><strong>功能开发在独立分支</strong>：一个功能一个分支，互不干扰</li><li><strong>通过 PR 合并代码</strong>：所有代码必须经过审查才能进入主分支</li><li><strong>小步快跑</strong>：分支生命周期越短越好，避免大规模合并</li></ol><h2 id="验收清单" tabindex="-1">验收清单 <a class="header-anchor" href="#验收清单" aria-label="Permalink to &quot;验收清单&quot;">​</a></h2><ul><li>[ ] 理解分支策略的必要性</li><li>[ ] 能根据项目特点选择合适的分支模型</li><li>[ ] 知道如何配置分支保护规则</li><li>[ ] 掌握 PR 和代码审查的基本流程</li></ul>',10))])}const x=o(c,[["render",b]]);export{E as __pageData,x as default};
