import{_ as a,c as s,o as n,a3 as l}from"./chunks/framework.CUcrqFol.js";const u=JSON.parse('{"title":"2.3.1 MVP基础：从概念到深层含义","description":"2.3.1 MVP基础：从概念到深层含义 一个熟悉的场景 还记得前面提到的小李吗？他在学习了「任务视角」后，重新审视了自己的待办清单项目。 这次，他明确了核心任务：**帮助职场人士不遗漏重要的事情**。 然后他又犯了另一个错误。 他打开AI工具，输入： \\"我要做一个帮职场人士不遗漏事情的待办清单。需要这些功能：添加任务","frontmatter":{"title":"2.3.1 MVP基础：从概念到深层含义"},"headers":[],"relativePath":"Basic/02-mindset/2.3-subtraction-thinking/2.3.1-mvp-foundations.md","filePath":"Basic/02-mindset/2.3-subtraction-thinking/2.3.1-mvp-foundations.md","lastUpdated":1766596997000}'),e={name:"Basic/02-mindset/2.3-subtraction-thinking/2.3.1-mvp-foundations.md"};function i(p,t,o,r,d,h){return n(),s("div",null,[...t[0]||(t[0]=[l(`<h1 id="_2-3-1-mvp基础-从概念到深层含义" tabindex="-1">2.3.1 MVP基础：从概念到深层含义 <a class="header-anchor" href="#_2-3-1-mvp基础-从概念到深层含义" aria-label="Permalink to &quot;2.3.1 MVP基础：从概念到深层含义&quot;">​</a></h1><h2 id="一个熟悉的场景" tabindex="-1">一个熟悉的场景 <a class="header-anchor" href="#一个熟悉的场景" aria-label="Permalink to &quot;一个熟悉的场景&quot;">​</a></h2><p>还记得前面提到的小李吗？他在学习了「任务视角」后，重新审视了自己的待办清单项目。</p><p>这次，他明确了核心任务：<strong>帮助职场人士不遗漏重要的事情</strong>。</p><p>然后他又犯了另一个错误。</p><p>他打开AI工具，输入：</p><blockquote><p>&quot;我要做一个帮职场人士不遗漏事情的待办清单。需要这些功能：添加任务、完成任务、查看任务、任务分类、优先级标签、截止日期提醒、重复任务、子任务拆解……&quot;</p></blockquote><p>他列了14个功能。</p><p>三个月后，项目又一次搁浅了。</p><h2 id="问题出在哪" tabindex="-1">问题出在哪？ <a class="header-anchor" href="#问题出在哪" aria-label="Permalink to &quot;问题出在哪？&quot;">​</a></h2><p>小李这次已经想清楚了「要解决什么问题」，但他陷入了另一个陷阱：<strong>功能堆砌</strong>。</p><p>他把「解决问题可能需要的所有功能」都列了出来，然后试图一次性全部实现。</p><p>这是一个非常常见的错误。</p><h2 id="传统mvp的误区" tabindex="-1">传统MVP的误区 <a class="header-anchor" href="#传统mvp的误区" aria-label="Permalink to &quot;传统MVP的误区&quot;">​</a></h2><p>很多人听说过MVP这个词，但普遍存在理解偏差：</p><blockquote><p>MVP = 功能数量最少的版本</p></blockquote><p>按照这个理解，可能会这样想：</p><ul><li>原来计划14个功能，那我砍到7个，这就是MVP了吧？</li></ul><p><strong>这是完全错误的。</strong></p><p>MVP不是「功能最少」，而是「能验证核心假设的最小投入」。</p><h2 id="mvp的三个字母深度解读" tabindex="-1">MVP的三个字母深度解读 <a class="header-anchor" href="#mvp的三个字母深度解读" aria-label="Permalink to &quot;MVP的三个字母深度解读&quot;">​</a></h2><h3 id="m-minimum-最小" tabindex="-1">M = Minimum（最小） <a class="header-anchor" href="#m-minimum-最小" aria-label="Permalink to &quot;M = Minimum（最小）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>错误理解</th><th>正确理解</th></tr></thead><tbody><tr><td>功能数量最少</td><td><strong>投入成本最少</strong></td></tr><tr><td>砍掉「不重要」的功能</td><td>砍掉「不能验证假设」的功能</td></tr><tr><td>做一个「简陋版」</td><td>做一个「聚焦版」</td></tr></tbody></table><p><strong>关键洞见</strong>：「最小」的对象是你的投入（时间、精力、金钱），不是功能列表。</p><p><strong>实际例子</strong>：</p><ul><li>Dropbox的MVP是一个3分钟演示视频，投入最小</li><li>某习惯打卡App的MVP只有一个按钮，投入最小</li><li>你的MVP应该是能验证假设的最小投入形式</li></ul><h3 id="v-viable-可行" tabindex="-1">V = Viable（可行） <a class="header-anchor" href="#v-viable-可行" aria-label="Permalink to &quot;V = Viable（可行）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>错误理解</th><th>正确理解</th></tr></thead><tbody><tr><td>能跑起来、不报错</td><td><strong>能验证核心假设</strong></td></tr><tr><td>技术上可行</td><td>商业/价值上可行</td></tr><tr><td>「它能工作」</td><td>「它能证明或否定我的假设」</td></tr></tbody></table><p><strong>关键洞见</strong>：「可行」不是技术概念，而是验证概念。</p><p><strong>实际例子</strong>：</p><ul><li>一个能完美运行但没人用的App，不是「可行」的</li><li>一个有bug但能验证用户确实需要这个功能的原型，是「可行」的</li><li>判断标准不是「它跑得好不好」，而是「它能不能告诉我假设对不对」</li></ul><h3 id="p-product-产品" tabindex="-1">P = Product（产品） <a class="header-anchor" href="#p-product-产品" aria-label="Permalink to &quot;P = Product（产品）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>错误理解</th><th>正确理解</th></tr></thead><tbody><tr><td>完整的软件/App</td><td><strong>能给用户价值的东西</strong></td></tr><tr><td>必须是代码</td><td>可以是任何形式</td></tr><tr><td>必须能「发布」</td><td>只要能验证就行</td></tr></tbody></table><p><strong>关键洞见</strong>：「产品」可以是任何能交付价值的东西。</p><p><strong>实际例子</strong>：</p><ul><li>一个手绘的界面草图（验证用户是否理解你的设计）</li><li>一个Excel表格（验证你的数据分析逻辑是否有效）</li><li>一段人工执行的流程（验证这个流程是否真的能解决问题）</li><li>一个落地页（验证用户是否愿意注册）</li></ul><h2 id="mvp的本质-一个实验" tabindex="-1">MVP的本质：一个实验 <a class="header-anchor" href="#mvp的本质-一个实验" aria-label="Permalink to &quot;MVP的本质：一个实验&quot;">​</a></h2><p>理解了这三个词，你会发现MVP的本质是：</p><blockquote><p><strong>用最小的投入，验证核心假设，交付最小的价值。</strong></p></blockquote><p>它不是一个「产品」，而是一个「实验」。</p><p>实验的目的是获取信息：</p><ul><li>我的假设对吗？</li><li>用户真的需要这个吗？</li><li>这个方向值得继续投入吗？</li></ul><h2 id="核心假设的重要性" tabindex="-1">核心假设的重要性 <a class="header-anchor" href="#核心假设的重要性" aria-label="Permalink to &quot;核心假设的重要性&quot;">​</a></h2><p>MVP存在的意义是验证假设。那么，什么是核心假设？</p><p><strong>核心假设</strong>是你做这件事的基本前提。如果这个假设不成立，整个项目就没有价值。</p><h3 id="核心假设模板" tabindex="-1">核心假设模板 <a class="header-anchor" href="#核心假设模板" aria-label="Permalink to &quot;核心假设模板&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我假设：</span></span>
<span class="line"><span>[某类用户] 存在 [某个问题/需求]，</span></span>
<span class="line"><span>他们愿意使用 [我的解决方案] 来 [完成某个任务]，</span></span>
<span class="line"><span>因为它比现有方案 [更快/更简单/更便宜/更有效]。</span></span></code></pre></div><h3 id="实际应用示例" tabindex="-1">实际应用示例 <a class="header-anchor" href="#实际应用示例" aria-label="Permalink to &quot;实际应用示例&quot;">​</a></h3><p><strong>待办清单项目</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我假设：</span></span>
<span class="line"><span>职场人士存在「怕遗漏重要事项」的问题，</span></span>
<span class="line"><span>他们愿意使用一个极简待办工具来管理每日任务，</span></span>
<span class="line"><span>因为它比便签纸/手机备忘录更容易坚持使用。</span></span></code></pre></div><p><strong>数据分析项目</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我假设：</span></span>
<span class="line"><span>销售团队存在「不知道哪个渠道ROI最高」的问题，</span></span>
<span class="line"><span>他们愿意使用一张清晰的对比图表来做决策，</span></span>
<span class="line"><span>因为它比Excel表格更直观，决策更快。</span></span></code></pre></div><p><strong>自动化脚本项目</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我假设：</span></span>
<span class="line"><span>财务部门存在「手动汇总报表耗时」的问题，</span></span>
<span class="line"><span>他们愿意使用一个自动化脚本来处理数据，</span></span>
<span class="line"><span>因为它比人工操作更准确，节省2小时/天。</span></span></code></pre></div><p><strong>家庭网页项目</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我假设：</span></span>
<span class="line"><span>年迈父母存在「记不住吃药时间」的问题，</span></span>
<span class="line"><span>他们愿意使用一个简单的网页来记录，</span></span>
<span class="line"><span>因为它比纸质日历更醒目，子女也能远程查看。</span></span></code></pre></div><h2 id="经典案例-dropbox的mvp" tabindex="-1">经典案例：Dropbox的MVP <a class="header-anchor" href="#经典案例-dropbox的mvp" aria-label="Permalink to &quot;经典案例：Dropbox的MVP&quot;">​</a></h2><p>2007年，Drew Houston想做一个云端文件同步工具。</p><p>他面临一个问题：这个产品需要大量开发工作，但他不确定用户是否真的需要它。</p><p>他的解决方案：<strong>不写一行代码，先做一个3分钟的演示视频</strong>。</p><p>视频展示了「文件自动同步到云端」的效果（实际上是剪辑合成的），然后放到网上。</p><p>结果：一夜之间，等待名单从5,000人涨到75,000人。</p><p>这个视频就是Dropbox的MVP。它验证了核心假设：「人们确实需要一个简单易用的文件同步工具」。</p><h2 id="mvp的实际应用指南" tabindex="-1">MVP的实际应用指南 <a class="header-anchor" href="#mvp的实际应用指南" aria-label="Permalink to &quot;MVP的实际应用指南&quot;">​</a></h2><h3 id="第一步-明确核心假设" tabindex="-1">第一步：明确核心假设 <a class="header-anchor" href="#第一步-明确核心假设" aria-label="Permalink to &quot;第一步：明确核心假设&quot;">​</a></h3><p>在开始任何项目前，先填写这个模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>项目名称：[你的项目]</span></span>
<span class="line"><span>核心假设：</span></span></code></pre></div><h3 id="第二步-确定最小验证方式" tabindex="-1">第二步：确定最小验证方式 <a class="header-anchor" href="#第二步-确定最小验证方式" aria-label="Permalink to &quot;第二步：确定最小验证方式&quot;">​</a></h3><p>问自己：</p><ul><li>用什么最小的方式可以验证这个假设？</li><li>什么是「最便宜」的验证方法？</li><li>多少时间/金钱投入是可以接受的「试错成本」？</li></ul><h3 id="第三步-设定成功标准" tabindex="-1">第三步：设定成功标准 <a class="header-anchor" href="#第三步-设定成功标准" aria-label="Permalink to &quot;第三步：设定成功标准&quot;">​</a></h3><p>什么样的结果说明「假设成立」？</p><ul><li>多少用户愿意试用？</li><li>用户使用频率如何？</li><li>用户反馈是什么？</li></ul><h3 id="第四步-执行和学习" tabindex="-1">第四步：执行和学习 <a class="header-anchor" href="#第四步-执行和学习" aria-label="Permalink to &quot;第四步：执行和学习&quot;">​</a></h3><ul><li>快速构建MVP</li><li>收集真实数据和反馈</li><li>决定：继续迭代、调整方向、还是放弃</li></ul><h2 id="常见mvp形式" tabindex="-1">常见MVP形式 <a class="header-anchor" href="#常见mvp形式" aria-label="Permalink to &quot;常见MVP形式&quot;">​</a></h2><p>根据不同的项目类型，MVP可以采用不同形式：</p><table tabindex="0"><thead><tr><th>项目类型</th><th>MVP形式</th><th>验证目标</th></tr></thead><tbody><tr><td>软件应用</td><td>纸质原型/单功能页面</td><td>用户是否理解并愿意使用</td></tr><tr><td>数据分析</td><td>手工制作的图表</td><td>决策者是否觉得有用</td></tr><tr><td>自动化</td><td>手动执行的流程</td><td>这个流程是否真的能解决问题</td></tr><tr><td>内容产品</td><td>一篇测试文章/视频</td><td>用户是否愿意分享/讨论</td></tr><tr><td>服务流程</td><td>人工模拟的服务</td><td>用户是否愿意为此付费</td></tr></tbody></table><h2 id="mvp的判断标准" tabindex="-1">MVP的判断标准 <a class="header-anchor" href="#mvp的判断标准" aria-label="Permalink to &quot;MVP的判断标准&quot;">​</a></h2><p>当你在考虑&quot;这个功能要不要加入MVP&quot;时，用以下问题判断：</p><ol><li><p><strong>没有这个功能，还能验证核心假设吗？</strong></p><ul><li>如果能 → 不要加入</li><li>如果不能 → 考虑加入</li></ul></li><li><p><strong>这个功能是为了验证假设，还是为了取悦用户？</strong></p><ul><li>验证假设 → 可以考虑</li><li>取悦用户 → 暂时不做</li></ul></li><li><p><strong>有没有更简单的方式达到同样的验证效果？</strong></p><ul><li>如果有 → 选择更简单的方式</li><li>如果没有 → 当前方案可能是最优的</li></ul></li><li><p><strong>如果这个功能验证失败，整个项目还值得继续吗？</strong></p><ul><li>如果值得 → 这是核心功能</li><li>如果不值得 → 这不是核心功能</li></ul></li></ol><h2 id="mvp的常见误区" tabindex="-1">MVP的常见误区 <a class="header-anchor" href="#mvp的常见误区" aria-label="Permalink to &quot;MVP的常见误区&quot;">​</a></h2><h3 id="误区1-把mvp当做-半成品" tabindex="-1">误区1：把MVP当做&quot;半成品&quot; <a class="header-anchor" href="#误区1-把mvp当做-半成品" aria-label="Permalink to &quot;误区1：把MVP当做&quot;半成品&quot;&quot;">​</a></h3><p><strong>错误做法</strong>：做一个功能不完整、体验很差的东西，然后说&quot;这是MVP&quot;。</p><p><strong>正确理解</strong>：MVP应该是一个完整的、能交付价值的最小闭环。</p><h3 id="误区2-所有功能都要做-只是做得简单些" tabindex="-1">误区2：所有功能都要做，只是做得简单些 <a class="header-anchor" href="#误区2-所有功能都要做-只是做得简单些" aria-label="Permalink to &quot;误区2：所有功能都要做，只是做得简单些&quot;">​</a></h3><p><strong>错误做法</strong>：原来计划10个功能，现在每个功能都做一个简化版。</p><p><strong>正确理解</strong>：只做能验证核心假设的最少功能集。</p><h3 id="误区3-mvp就是质量差" tabindex="-1">误区3：MVP就是质量差 <a class="header-anchor" href="#误区3-mvp就是质量差" aria-label="Permalink to &quot;误区3：MVP就是质量差&quot;">​</a></h3><p><strong>错误做法</strong>：因为是最小版本，所以不考虑质量，随便做做。</p><p><strong>正确理解</strong>：MVP在核心功能上应该做到足够好，能够真实反映用户需求。</p><h2 id="这对你意味着什么" tabindex="-1">这对你意味着什么 <a class="header-anchor" href="#这对你意味着什么" aria-label="Permalink to &quot;这对你意味着什么&quot;">​</a></h2><p>在开始动手之前，问自己一个关键问题：</p><blockquote><p>我的核心假设是什么？用什么最小的方式可以验证它？</p></blockquote><p>对于小李的待办清单项目：</p><ul><li><strong>核心假设</strong>：职场人士愿意用一个极简工具来管理每日待办，而不是用便签纸或手机备忘录</li><li><strong>最小验证方式</strong>：一个只有「添加-完成-查看」三个功能的页面</li></ul><p>如果这三个功能都留不住用户，加再多功能也没用。</p><p>如果这三个功能能留住用户，说明假设成立，可以继续迭代。</p><h2 id="多场景应用" tabindex="-1">多场景应用 <a class="header-anchor" href="#多场景应用" aria-label="Permalink to &quot;多场景应用&quot;">​</a></h2><p>减法思维不只适用于「做产品」：</p><table tabindex="0"><thead><tr><th>场景</th><th>核心假设示例</th><th>MVP形式</th></tr></thead><tbody><tr><td>数据分析报告</td><td>老板最关心的是销售转化率</td><td>先做一张转化率趋势图，看老板反馈</td></tr><tr><td>自动化脚本</td><td>Excel汇总是最耗时的重复工作</td><td>先自动化一个部门的汇总，验证效果</td></tr><tr><td>给爸妈做吃药提醒</td><td>他们能看懂大字和简单按钮</td><td>一个只有「吃了」按钮的页面</td></tr><tr><td>学习笔记App</td><td>记笔记的核心痛点是「找不到」</td><td>一个只有搜索功能的笔记工具</td></tr><tr><td>项目管理工具</td><td>团队最需要的是「知道谁在做什么」</td><td>一个简单的任务状态看板</td></tr></tbody></table><h2 id="核心要点总结" tabindex="-1">核心要点总结 <a class="header-anchor" href="#核心要点总结" aria-label="Permalink to &quot;核心要点总结&quot;">​</a></h2><p>通过本节学习，你现在理解了MVP的真正含义：</p><ul><li>MVP是实验，不是产品</li><li>它的目的是验证假设，不是取悦用户</li><li>「最小」指的是投入成本，不是功能数量</li><li>「可行」指的是能验证假设，不是技术上能运行</li><li>「产品」指的是能交付价值的东西，不一定是代码</li></ul><p>理解了这些基础概念，你就能更好地应用减法思维，避免功能堆砌的陷阱。接下来，我们通过真实案例，看看「做减法」和「堆功能」的项目有什么不同。</p>`,105)])])}const b=a(e,[["render",i]]);export{u as __pageData,b as default};
