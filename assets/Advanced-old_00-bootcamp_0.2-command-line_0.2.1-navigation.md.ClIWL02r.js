import{_ as r,C as a,c as n,o as e,a3 as t,b as s,w as d,a as l,G as i,a4 as u}from"./chunks/framework.CUcrqFol.js";const P=JSON.parse('{"title":"0.2.1 导航：在数字世界里自由穿梭","description":"0.2.1 导航：在数字世界里自由穿梭 一句话破题 命令行导航，就是通过几个核心指令，让你在文件系统的“目录树”中快速定位和移动，就像在游戏地图里使用传送点一样高效。 核心价值 **效率**：当你熟悉了路径和指令，直接输入命令跳转，远比在图形界面中一层层点击文件夹要快得多。 **精确**：你可以直接到达任何深度的目录，","frontmatter":{"title":"0.2.1 导航：在数字世界里自由穿梭","typora-root-url":"../public"},"headers":[],"relativePath":"Advanced-old/00-bootcamp/0.2-command-line/0.2.1-navigation.md","filePath":"Advanced-old/00-bootcamp/0.2-command-line/0.2.1-navigation.md","lastUpdated":1766168364000}'),p={name:"Advanced-old/00-bootcamp/0.2-command-line/0.2.1-navigation.md"};function m(g,o,h,_,A,D){const c=a("Mermaid");return e(),n("div",null,[o[1]||(o[1]=t('<h1 id="_0-2-1-导航-在数字世界里自由穿梭" tabindex="-1">0.2.1 导航：在数字世界里自由穿梭 <a class="header-anchor" href="#_0-2-1-导航-在数字世界里自由穿梭" aria-label="Permalink to &quot;0.2.1 导航：在数字世界里自由穿梭&quot;">​</a></h1><h3 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h3><p>命令行导航，就是通过几个核心指令，让你在文件系统的“目录树”中快速定位和移动，就像在游戏地图里使用传送点一样高效。</p><h3 id="核心价值" tabindex="-1">核心价值 <a class="header-anchor" href="#核心价值" aria-label="Permalink to &quot;核心价值&quot;">​</a></h3><ol><li><strong>效率</strong>：当你熟悉了路径和指令，直接输入命令跳转，远比在图形界面中一层层点击文件夹要快得多。</li><li><strong>精确</strong>：你可以直接到达任何深度的目录，而不需要记住中间路径的每一个细节。</li><li><strong>自动化</strong>：导航是所有自动化脚本的基础。你需要先“去到”正确的地方，才能执行后续操作。</li></ol><h3 id="核心概念解析" tabindex="-1">核心概念解析 <a class="header-anchor" href="#核心概念解析" aria-label="Permalink to &quot;核心概念解析&quot;">​</a></h3><p>命令行导航主要依赖两个核心命令：<code>pwd</code> 和 <code>cd</code>，以及对路径的理解。</p><ul><li><p><strong><code>pwd</code> (Print Working Directory)</strong>：打印当前工作目录。这个命令告诉你“你现在在哪里”。</p><ul><li>Windows PowerShell 中对应的命令是 <code>Get-Location</code>，但 <code>pwd</code> 作为别名通常也能使用。</li></ul></li><li><p><strong><code>cd</code> (Change Directory)</strong>：切换目录。这是导航的核心，后面需要跟一个路径作为参数。</p></li><li><p><strong>路径 (Path)</strong>：</p><ul><li><strong>绝对路径</strong>：从根目录开始的完整路径，例如 <code>C:\\Users\\YourName\\Desktop</code> (Windows) 或 <code>/Users/YourName/Desktop</code> (macOS/Linux)。它提供了唯一的、明确的位置。</li><li><strong>相对路径</strong>：相对于你当前位置的路径。 <ul><li><code>.</code> (一个点)：代表<strong>当前目录</strong>。</li><li><code>..</code> (两个点)：代表<strong>上一级目录</strong>。</li></ul></li></ul></li></ul><h4 id="可视化解构" tabindex="-1">可视化解构 <a class="header-anchor" href="#可视化解构" aria-label="Permalink to &quot;可视化解构&quot;">​</a></h4><p>假设我们的文件结构如下，并且当前我们在 <code>ProjectA</code> 目录下。</p>',10)),(e(),s(u,null,{default:d(()=>[i(c,{id:"mermaid-89",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20subgraph%20sg1%20%5B%22%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%22%5D%0A%20%20%20%20%20%20%20%20Users%5B%22Users%22%5D%20--%3E%20YourName%5B%22YourName%22%5D%3B%0A%20%20%20%20%20%20%20%20YourName%20--%3E%20Desktop%5B%22Desktop%22%5D%3B%0A%20%20%20%20%20%20%20%20YourName%20--%3E%20Documents%5B%22Documents%22%5D%3B%0A%20%20%20%20%20%20%20%20Documents%20--%3E%20ProjectA%5B%22ProjectA%22%5D%3B%0A%20%20%20%20%20%20%20%20Documents%20--%3E%20ProjectB%5B%22ProjectB%22%5D%3B%0A%20%20%20%20end%0A%0A%20%20%20%20style%20ProjectA%20fill%3A%23f9f%2Cstroke%3A%23333%2Cstroke-width%3A2px%0A"})]),fallback:d(()=>[...o[0]||(o[0]=[l(" Loading... ",-1)])]),_:1})),o[2]||(o[2]=t('<table tabindex="0"><thead><tr><th>你的目标</th><th>使用的命令 (相对路径)</th><th>解释</th></tr></thead><tbody><tr><td>查看当前位置</td><td><code>pwd</code></td><td>输出 <code>/Users/YourName/Documents/ProjectA</code></td></tr><tr><td>进入 <code>Documents</code> 目录</td><td><code>cd ..</code></td><td><code>..</code> 代表上一级，即从 <code>ProjectA</code> 回到 <code>Documents</code></td></tr><tr><td>从 <code>Documents</code> 进入 <code>ProjectB</code></td><td><code>cd ProjectB</code></td><td>直接进入当前目录下的子目录 <code>ProjectB</code></td></tr><tr><td>从 <code>ProjectB</code> 直接回到 <code>Desktop</code></td><td><code>cd ../../Desktop</code></td><td>连续使用 <code>..</code>，两次返回上一级，再进入 <code>Desktop</code></td></tr><tr><td>任何位置去 <code>ProjectA</code></td><td><code>cd /Users/YourName/Documents/ProjectA</code></td><td>使用绝对路径，一步到位</td></tr></tbody></table><h3 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h3><p>当你需要 AI 帮你写脚本时，清晰地描述路径和导航意图非常重要。</p><ul><li><strong>核心意图</strong>：告诉 AI 你的<strong>当前位置</strong>和<strong>目标位置</strong>。</li><li><strong>需求定义公式</strong>：<code>“我当前在 [起始路径] 目录下，请写一个命令，让我可以进入 [目标路径] 目录。”</code></li><li><strong>关键术语</strong>：<code>当前目录 (current directory)</code>, <code>上一级目录 (parent directory)</code>, <code>根目录 (root directory)</code>, <code>cd</code>, <code>pwd</code>。</li></ul><p><strong>示例</strong>：</p><blockquote><p><strong>Bad ❌</strong>: “怎么去我的项目文件夹？” <em>AI 不知道你的项目文件夹在哪里。</em></p><p><strong>Good ✅</strong>: “我的项目路径是 <code>D:\\workspace\\my-awesome-project</code>。我现在命令行的路径是 <code>D:\\workspace</code>。请给我一个 <code>cd</code> 命令进入我的项目目录。”</p></blockquote><h3 id="避坑指南" tabindex="-1">避坑指南 <a class="header-anchor" href="#避坑指南" aria-label="Permalink to &quot;避坑指南&quot;">​</a></h3><ul><li><strong>路径中的空格</strong>：如果你的目录名包含空格（例如 <code>My Documents</code>），你需要用引号把整个路径包起来，像这样：<code>cd &quot;My Documents&quot;</code>。</li><li><strong>Windows vs macOS/Linux 的斜杠</strong>：Windows 使用反斜杠 <code>\\</code> 作为路径分隔符，而 macOS/Linux 使用正斜杠 <code>/</code>。不过，在现代的命令行工具（如 PowerShell）中，通常两者都能被正确识别，但保持原生习惯是最佳实践。</li><li><strong>Tab 自动补全</strong>：这是命令行导航的“超级技能”！输入路径的前几个字母，然后按 <code>Tab</code> 键，系统会自动帮你补全剩下的部分。如果存在多个匹配项，多按几次 <code>Tab</code> 会列出所有选项。<strong>一定要养成使用 <code>Tab</code> 的习惯，这能极大提升效率并减少拼写错误。</strong></li></ul>',8))])}const B=r(p,[["render",m]]);export{P as __pageData,B as default};
