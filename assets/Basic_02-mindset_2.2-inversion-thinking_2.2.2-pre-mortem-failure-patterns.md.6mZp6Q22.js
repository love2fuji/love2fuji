import{_ as i,c as o,o as t,a3 as r}from"./chunks/framework.CUcrqFol.js";const h=JSON.parse('{"title":"2.2.2 Pre-mortem失败模式分析：Vibe Coding项目避坑指南","description":"2.2.2 Pre-mortem失败模式分析：Vibe Coding项目避坑指南 根据大量实践经验，Vibe Coding项目最常见的失败原因可以分为几大类。了解这些\\"前人踩过的坑\\"，可以帮助你在做Pre-mortem时更全面地思考。 需求层面的失败模式 模式一：需求不清晰 **典型表现：** \\"帮我做一个好用的App","frontmatter":{"title":"2.2.2 Pre-mortem失败模式分析：Vibe Coding项目避坑指南"},"headers":[],"relativePath":"Basic/02-mindset/2.2-inversion-thinking/2.2.2-pre-mortem-failure-patterns.md","filePath":"Basic/02-mindset/2.2-inversion-thinking/2.2.2-pre-mortem-failure-patterns.md","lastUpdated":1766596997000}'),a={name:"Basic/02-mindset/2.2-inversion-thinking/2.2.2-pre-mortem-failure-patterns.md"};function e(n,l,u,s,p,g){return t(),o("div",null,[...l[0]||(l[0]=[r('<h1 id="_2-2-2-pre-mortem失败模式分析-vibe-coding项目避坑指南" tabindex="-1">2.2.2 Pre-mortem失败模式分析：Vibe Coding项目避坑指南 <a class="header-anchor" href="#_2-2-2-pre-mortem失败模式分析-vibe-coding项目避坑指南" aria-label="Permalink to &quot;2.2.2 Pre-mortem失败模式分析：Vibe Coding项目避坑指南&quot;">​</a></h1><p>根据大量实践经验，Vibe Coding项目最常见的失败原因可以分为几大类。了解这些&quot;前人踩过的坑&quot;，可以帮助你在做Pre-mortem时更全面地思考。</p><h2 id="需求层面的失败模式" tabindex="-1">需求层面的失败模式 <a class="header-anchor" href="#需求层面的失败模式" aria-label="Permalink to &quot;需求层面的失败模式&quot;">​</a></h2><h3 id="模式一-需求不清晰" tabindex="-1">模式一：需求不清晰 <a class="header-anchor" href="#模式一-需求不清晰" aria-label="Permalink to &quot;模式一：需求不清晰&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;帮我做一个好用的App&quot;</li><li>&quot;我想要一个能提高效率的工具&quot;</li></ul><p><strong>失败机制：</strong> AI无法读心。&quot;好用&quot;对你意味着什么？&quot;提高效率&quot;具体指哪个环节？模糊的输入只会得到模糊的输出。AI会按照它的理解去实现，而它的理解很可能和你想的完全不同。</p><p><strong>实际案例：</strong> 用户让AI&quot;做一个笔记App&quot;。AI做出来的是一个功能完整的Markdown编辑器，支持语法高亮、导出PDF、多级文件夹……但用户只是想要一个能快速记录灵感的地方，一句话就够了。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>需求描述充满形容词（好用、高效、强大）</li><li>没有具体的使用场景</li><li>缺乏可衡量的成功标准</li></ul><p><strong>预防措施：</strong></p><ol><li>具体化描述：要做什么，在什么情况下，为谁服务</li><li>使用JTBD框架明确&quot;雇佣&quot;任务</li><li>设定可衡量的验收标准</li></ol><h3 id="模式二-功能复杂度爆炸" tabindex="-1">模式二：功能复杂度爆炸 <a class="header-anchor" href="#模式二-功能复杂度爆炸" aria-label="Permalink to &quot;模式二：功能复杂度爆炸&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>第一版就要20个功能</li><li>&quot;像XX产品一样，但要有这些改进……&quot;</li></ul><p><strong>失败机制：</strong> 复杂度的增长是指数级的，不是线性的。</p><ul><li>2个功能之间可能有1种交互关系</li><li>5个功能之间可能有10种交互关系</li><li>20个功能之间可能有190种交互关系</li></ul><p>AI处理复杂系统时更容易出错，也更难发现和定位问题。</p><p><strong>实际案例：</strong> 某用户一次性要求AI实现&quot;用户注册、登录、个人中心、任务管理、团队协作、权限控制、数据统计、消息通知&quot;。结果代码越改越乱，三天后整个项目变成了一团无法维护的意大利面条。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>功能列表超过10项</li><li>功能之间缺乏明确的优先级</li><li>试图一次性满足所有用户需求</li></ul><p><strong>预防措施：</strong></p><ol><li>严格限制核心功能（3-5个）</li><li>使用MVP思维，先验证核心价值</li><li>建立明确的&quot;不做清单&quot;</li></ol><h3 id="模式三-功能与任务脱节" tabindex="-1">模式三：功能与任务脱节 <a class="header-anchor" href="#模式三-功能与任务脱节" aria-label="Permalink to &quot;模式三：功能与任务脱节&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;我要做一个功能全面的工具&quot;</li><li>&quot;参考XX产品，但要有这些特色&quot;</li></ul><p><strong>失败机制：</strong> 没有从用户实际需求出发，而是在堆砌功能。</p><p><strong>实际案例：</strong> 某用户想要做&quot;项目管理工具&quot;，参考Jira等工具。但他没有分析自己团队的实际工作流程，结果做出来的工具功能虽然全面，但不符合团队习惯，最后还是回到了用Excel+微信群的方式。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>以&quot;参考某产品&quot;为设计起点</li><li>功能描述脱离具体使用场景</li><li>没有明确的核心用户画像</li></ul><p><strong>预防措施：</strong></p><ol><li>深入分析用户真实任务</li><li>先了解现有替代方案的优缺点</li><li>从解决具体问题出发，而非复制功能</li></ol><h2 id="技术层面的失败模式" tabindex="-1">技术层面的失败模式 <a class="header-anchor" href="#技术层面的失败模式" aria-label="Permalink to &quot;技术层面的失败模式&quot;">​</a></h2><h3 id="模式一-技术选型不当" tabindex="-1">模式一：技术选型不当 <a class="header-anchor" href="#模式一-技术选型不当" aria-label="Permalink to &quot;模式一：技术选型不当&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;我要用最新的技术栈&quot;</li><li>&quot;这个架构更先进&quot;</li></ul><p><strong>失败机制：</strong> 追求&quot;新&quot;和&quot;酷&quot;而不是&quot;合适&quot;。新技术可能：</p><ul><li>文档和社区资源不足</li><li>与AI工具的兼容性问题</li><li>学习成本过高，项目停滞</li></ul><p><strong>实际案例：</strong> 某用户坚持使用最新的前端框架，结果发现：</p><ul><li>AI生成的代码经常出现兼容性问题</li><li>遇到bug时，Stack Overflow上几乎没有解决方案</li><li>项目两个月后因为技术债务太多而放弃</li></ul><p><strong>Pre-mortem警示信号：</strong></p><ul><li>选择技术的理由是&quot;新&quot;、&quot;酷&quot;、&quot;先进&quot;</li><li>对技术的学习难度估计不足</li><li>没有考虑与AI工具的兼容性</li></ul><p><strong>预防措施：</strong></p><ol><li>选择成熟、有良好文档的技术</li><li>优先考虑AI工具支持度</li><li>评估自己的学习时间和维护成本</li></ol><h3 id="模式二-过度依赖ai" tabindex="-1">模式二：过度依赖AI <a class="header-anchor" href="#模式二-过度依赖ai" aria-label="Permalink to &quot;模式二：过度依赖AI&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;完全按照AI的建议做，不做任何调整&quot;</li><li>&quot;AI说没问题，那肯定没问题&quot;</li></ul><p><strong>失败机制：</strong> AI不是全知的。它会：</p><ul><li>有时候&quot;忘记&quot;前面的上下文</li><li>在某些复杂问题上给出错误建议</li><li>缺乏对业务需求的理解</li></ul><p><strong>实际案例：</strong> 某用户完全按照AI的建议设计数据库结构，但没有进行合理性验证。结果在生产环境中发现性能问题，数据量一增长就卡死了。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>完全信任AI的输出，不做验证</li><li>遇到错误时不进行人工分析</li><li>缺乏基本的技术判断能力</li></ul><p><strong>预防措施：</strong></p><ol><li>保持&quot;信任但验证&quot;的态度</li><li>学习基础的技术判断能力</li><li>建立自己的决策框架，AI只是辅助工具</li></ol><h3 id="模式三-缺乏基础技术判断" tabindex="-1">模式三：缺乏基础技术判断 <a class="header-anchor" href="#模式三-缺乏基础技术判断" aria-label="Permalink to &quot;模式三：缺乏基础技术判断&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;AI说这个代码能运行，那肯定没问题&quot;</li><li>&quot;我看不到报错，应该就没问题吧？&quot;</li></ul><p><strong>失败机制：</strong> 缺乏基础的技术判断能力：</p><ul><li>无法识别潜在的安全问题</li><li>不能理解代码的性能影响</li><li>遇到错误时无法有效调试</li></ul><p><strong>实际案例：</strong> 某用户的网站运行几个月后被黑客攻击。原因是AI生成的代码中存在SQL注入漏洞，但用户没有技术基础识别出来。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>对代码的安全性、性能一无所知</li><li>遇到问题时完全依赖AI</li><li>缺乏基本的测试和验证习惯</li></ul><p><strong>预防措施：</strong></p><ol><li>学习基础的安全和性能知识</li><li>建立测试验证流程</li><li>遇到不确定的情况时寻求专业意见</li></ol><h2 id="场景层面的失败模式" tabindex="-1">场景层面的失败模式 <a class="header-anchor" href="#场景层面的失败模式" aria-label="Permalink to &quot;场景层面的失败模式&quot;">​</a></h2><h3 id="模式一-用户群体判断错误" tabindex="-1">模式一：用户群体判断错误 <a class="header-anchor" href="#模式一-用户群体判断错误" aria-label="Permalink to &quot;模式一：用户群体判断错误&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;所有人都能用&quot;</li><li>&quot;这个市场需求很大&quot;</li></ul><p><strong>失败机制：</strong> 过于宽泛的目标用户定义，导致：</p><ul><li>需求冲突，无法满足所有人</li><li>产品缺乏针对性，没有核心用户群体</li><li>营销和推广策略无效</li></ul><p><strong>实际案例：</strong> 某用户想做&quot;大学生学习工具&quot;，但没有细分。结果发现：</p><ul><li>大一新生和大四毕业生的需求完全不同</li><li>文科生和理科生的学习方式不同</li><li>勤工学生和全日制学生的时间安排不同</li></ul><p>最终产品因为&quot;谁都不太满意&quot;而失败。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>目标用户描述模糊（&quot;所有人&quot;、&quot;大众&quot;等）</li><li>没有具体的用户画像</li><li>试图解决所有人的所有问题</li></ul><p><strong>预防措施：</strong></p><ol><li>细分目标用户群体</li><li>建立具体的用户画像</li><li>先服务一个小群体，验证需求后再扩展</li></ol><h3 id="模式二-场景假设错误" tabindex="-1">模式二：场景假设错误 <a class="header-anchor" href="#模式二-场景假设错误" aria-label="Permalink to &quot;模式二：场景假设错误&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;用户会每天使用这个功能&quot;</li><li>&quot;这个功能肯定会受欢迎&quot;</li></ul><p><strong>失败机制：</strong> 没有基于真实观察做出场景假设。</p><p><strong>实际案例：</strong> 某用户认为&quot;白领会每天使用运动记录App&quot;。但实际调研发现：</p><ul><li>大多数人只有周末才运动</li><li>工作日根本没有时间和精力</li><li>运动记录更多是社交性质的，而非个人习惯</li></ul><p><strong>Pre-mortem警示信号：</strong></p><ul><li>场景假设基于自己的想象</li><li>没有进行实际调研或观察</li><li>忽视用户实际的生活习惯</li></ul><p><strong>预防措施：</strong></p><ol><li>进行真实的用户调研</li><li>观察目标用户的实际行为</li><li>基于数据而非想象做假设</li></ol><h3 id="模式三-替代方案评估不足" tabindex="-1">模式三：替代方案评估不足 <a class="header-anchor" href="#模式三-替代方案评估不足" aria-label="Permalink to &quot;模式三：替代方案评估不足&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;现有的工具太难用了&quot;</li><li>&quot;我的方案比现有的好多了&quot;</li></ul><p><strong>失败机制：</strong> 低估现有方案的价值和用户习惯。</p><p><strong>实际案例：</strong> 某用户认为&quot;Excel表格管理客户信息太麻烦&quot;，想做专门的CRM工具。但他没有考虑到：</p><ul><li>Excel功能已经足够满足基本需求</li><li>用户已经建立了长期的使用习惯</li><li>学习新工具需要时间和成本</li><li>数据迁移的复杂性</li></ul><p>结果CRM工具开发完成，但用户还是习惯用Excel。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>过度贬低现有方案</li><li>低估用户习惯的力量</li><li>忽略迁移成本和学习成本</li></ul><p><strong>预防措施：</strong></p><ol><li>深入分析现有方案的优缺点</li><li>理解用户使用现有方案的原因</li><li>评估迁移成本和收益</li></ol><h2 id="习惯层面的失败模式" tabindex="-1">习惯层面的失败模式 <a class="header-anchor" href="#习惯层面的失败模式" aria-label="Permalink to &quot;习惯层面的失败模式&quot;">​</a></h2><h3 id="模式一-高估持续使用意愿" tabindex="-1">模式一：高估持续使用意愿 <a class="header-anchor" href="#模式一-高估持续使用意愿" aria-label="Permalink to &quot;模式一：高估持续使用意愿&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;我肯定会坚持使用的&quot;</li><li>&quot;这个工具太有用了，不会放弃的&quot;</li></ul><p><strong>失败机制：</strong> 对新工具的持续使用意愿过于乐观。</p><p><strong>实际案例：</strong> 某用户开发了一个&quot;完美的时间管理App&quot;，功能强大，界面精美。但一个月后发现：</p><ul><li>手机里已经有很多类似App，功能重叠</li><li>新App需要手动输入数据，而其他App能自动同步</li><li>最终还是回到了最熟悉的老工具上</li></ul><p><strong>Pre-mortem警示信号：</strong></p><ul><li>基于个人喜好而非用户反馈</li><li>忽视市场竞争和替代方案</li><li>低估习惯的力量</li></ul><p><strong>预防措施：</strong></p><ol><li>考虑市场竞争情况</li><li>评估相比现有方案的优势</li><li>做小规模测试验证用户意愿</li></ol><h3 id="模式二-低估迁移成本" tabindex="-1">模式二：低估迁移成本 <a class="header-anchor" href="#模式二-低估迁移成本" aria-label="Permalink to &quot;模式二：低估迁移成本&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;数据迁移很简单的&quot;</li><li>&quot;只需要导入导出就行了&quot;</li></ul><p><strong>失败机制：</strong> 低估从现有方案迁移到新方案的成本。</p><p><strong>实际案例：</strong> 某用户认为&quot;从Notion迁移到新笔记工具很简单&quot;。但实际过程中发现：</p><ul><li>数据格式不兼容，需要手动重新整理</li><li>丢失了Notion的数据库关联关系</li><li>团队协作的权限和流程需要重建</li><li>迁移花费的时间比预期长3倍</li></ul><p><strong>Pre-mortem警示信号：</strong></p><ul><li>对迁移过程的复杂性认识不足</li><li>忽略数据格式和功能差异</li><li>低估用户的情感投入</li></ul><p><strong>预防措施：</strong></p><ol><li>详细分析迁移过程</li><li>提供迁移工具和指南</li><li>考虑渐进式迁移策略</li></ol><h3 id="模式三-忽视学习成本" tabindex="-1">模式三：忽视学习成本 <a class="header-anchor" href="#模式三-忽视学习成本" aria-label="Permalink to &quot;模式三：忽视学习成本&quot;">​</a></h3><p><strong>典型表现：</strong></p><ul><li>&quot;界面很简单，一看就会用&quot;</li><li>&quot;功能不多，很容易学会&quot;</li></ul><p><strong>失败机制：</strong> 低估用户学习新工具的认知成本。</p><p><strong>实际案例：</strong> 某用户设计的界面在开发者看来&quot;很简单直观&quot;。但目标用户反馈：</p><ul><li>找不到主要功能按钮</li><li>不理解图标的含义</li><li>不知道如何完成基本操作</li></ul><p>最终因为&quot;太难用&quot;而被放弃。</p><p><strong>Pre-mortem警示信号：</strong></p><ul><li>基于自己的技术理解判断易用性</li><li>缺乏目标用户的使用测试</li><li>忽视用户的知识背景差异</li></ul><p><strong>预防措施：</strong></p><ol><li>进行用户测试，观察实际使用过程</li><li>提供详细的使用指南和教程</li><li>设计渐进式的学习路径</li></ol><h2 id="失败模式检查清单" tabindex="-1">失败模式检查清单 <a class="header-anchor" href="#失败模式检查清单" aria-label="Permalink to &quot;失败模式检查清单&quot;">​</a></h2><h3 id="启动前检查" tabindex="-1">启动前检查 <a class="header-anchor" href="#启动前检查" aria-label="Permalink to &quot;启动前检查&quot;">​</a></h3><p>在开始项目前，对照以下问题进行检查：</p><p><strong>需求层面：</strong></p><ul><li>[ ] 我的需求描述足够具体吗？</li><li>[ ] 我知道为谁解决什么问题吗？</li><li>[ ] 核心功能是否控制在3-5个？</li><li>[ ] 我有明确的&quot;不做清单&quot;吗？</li></ul><p><strong>技术层面：</strong></p><ul><li>[ ] 我选择的技术适合当前需求吗？</li><li>[ ] 我对基本的技术风险有了解吗？</li><li>[ ] 我有代码审查和测试流程吗？</li><li>[ ] 我知道如何验证AI生成的代码吗？</li></ul><p><strong>场景层面：</strong></p><ul><li>[ ] 我的目标用户群体足够具体吗？</li><li>[ ] 我做过实际的用户调研吗？</li><li>[ ] 我了解现有替代方案吗？</li><li>[ ] 我评估过迁移成本吗？</li></ul><p><strong>习惯层面：</strong></p><ul><li>[ ] 我考虑过用户的持续使用意愿吗？</li><li>[ ] 我评估过学习成本吗？</li><li>[ ] 我有推广和留存计划吗？</li><li>[ ] 我做过小规模验证吗？</li></ul><h3 id="进行中检查" tabindex="-1">进行中检查 <a class="header-anchor" href="#进行中检查" aria-label="Permalink to &quot;进行中检查&quot;">​</a></h3><p>在项目进行过程中，定期检查：</p><ul><li>[ ] 用户反馈是否与预期一致？</li><li>[ ] 技术问题是否在可控范围内？</li><li>[ ] 用户实际使用场景是否符合假设？</li><li>[ ] 项目进展是否按计划进行？</li></ul><h2 id="失败模式学习指南" tabindex="-1">失败模式学习指南 <a class="header-anchor" href="#失败模式学习指南" aria-label="Permalink to &quot;失败模式学习指南&quot;">​</a></h2><h3 id="从失败中学习" tabindex="-1">从失败中学习 <a class="header-anchor" href="#从失败中学习" aria-label="Permalink to &quot;从失败中学习&quot;">​</a></h3><ol><li><strong>记录失败案例</strong>：详细记录每个失败项目的情况</li><li><strong>分析根本原因</strong>：找出表面问题背后的深层原因</li><li><strong>总结经验教训</strong>：提炼出可以应用到未来项目的教训</li><li><strong>建立检查清单</strong>：将教训转化为具体的预防措施</li></ol><h3 id="建立失败案例库" tabindex="-1">建立失败案例库 <a class="header-anchor" href="#建立失败案例库" aria-label="Permalink to &quot;建立失败案例库&quot;">​</a></h3><p>建议建立一个个人失败案例库，包含：</p><ul><li>项目背景和目标</li><li>失败的具体表现</li><li>失败原因分析</li><li>学到的教训</li><li>预防措施</li></ul><h3 id="定期回顾和更新" tabindex="-1">定期回顾和更新 <a class="header-anchor" href="#定期回顾和更新" aria-label="Permalink to &quot;定期回顾和更新&quot;">​</a></h3><p>定期回顾失败案例库：</p><ul><li>每季度回顾一次</li><li>根据新的经历更新案例</li><li>分享给团队成员共同学习</li><li>将教训转化为具体的流程和制度</li></ul><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>掌握了常见的失败模式后，接下来我们将学习：</p><ul><li><strong><a href="./2.2.3-pre-mortem-practical-guide.html">2.2.3 Pre-mortem实战指南</a></strong> - 学习具体的操作步骤、模板和工具</li></ul><p>通过了解这些失败模式，你可以在项目启动前就识别潜在风险，大大提高项目成功率。记住：<strong>了解失败是为了更好地成功</strong>。</p>',157)])])}const d=i(a,[["render",e]]);export{h as __pageData,d as default};
