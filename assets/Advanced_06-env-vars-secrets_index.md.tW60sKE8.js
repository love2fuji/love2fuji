import{_ as o,c as t,o as d,a3 as n}from"./chunks/framework.CUcrqFol.js";const _=JSON.parse('{"title":"第六章：环境变量与敏感信息管理","description":"第六章：环境变量与敏感信息管理 序言 在开始处理数据之前，老师傅严肃地拦住了你。他发现你正准备把 AI 平台的 API Key 和数据库密码直接写在代码里。他告诉你，这是编程界的大忌。现在的互联网上到处是 24 小时巡逻的爬虫，专门扫描 GitHub 上的公开仓库。如果你的代码里包含明文密钥，往往在你提交代码的几秒钟后","frontmatter":{"title":"第六章：环境变量与敏感信息管理"},"headers":[],"relativePath":"Advanced/06-env-vars-secrets/index.md","filePath":"Advanced/06-env-vars-secrets/index.md","lastUpdated":1766168364000}'),c={name:"Advanced/06-env-vars-secrets/index.md"};function r(s,e,i,a,g,l){return d(),t("div",null,[...e[0]||(e[0]=[n('<h1 id="第六章-环境变量与敏感信息管理" tabindex="-1">第六章：环境变量与敏感信息管理 <a class="header-anchor" href="#第六章-环境变量与敏感信息管理" aria-label="Permalink to &quot;第六章：环境变量与敏感信息管理&quot;">​</a></h1><h2 id="序言" tabindex="-1">序言 <a class="header-anchor" href="#序言" aria-label="Permalink to &quot;序言&quot;">​</a></h2><p>在开始处理数据之前，老师傅严肃地拦住了你。他发现你正准备把 AI 平台的 API Key 和数据库密码直接写在代码里。他告诉你，这是编程界的大忌。现在的互联网上到处是 24 小时巡逻的爬虫，专门扫描 GitHub 上的公开仓库。如果你的代码里包含明文密钥，往往在你提交代码的几秒钟后，你的 API 额度就会被盗刷一空，甚至背上巨额账单，这令你吓出一身冷汗。</p><p>你之前了解了使用 <code>.env</code> 文件来专门存放这些敏感信息。你明白了什么是环境变量——只有运行中的程序知道，而不会被写在明面上的代码里。</p><p>但单纯创建 <code>.env</code> 文件还不够，因为如果你一不小心执行了 <code>git add .</code>，这个文件还是会被打包上传到 GitHub。老师傅指着项目根目录下那个以点开头的文件 <strong><code>.gitignore</code></strong> 说，这才是防止你破产的最后一道防线。你可以把它理解为 Git 的<strong>屏蔽清单</strong>。凡是写在这个文件里的名字，Git 在扫描项目变动时都会<strong>假装没看见</strong>。</p><p>老师傅让你务必检查里面是否包含以下几类常见文件：</p><ul><li><strong>敏感配置</strong>：如 <code>.env</code>，这是绝对不能上传的“真钥匙”。</li><li><strong>依赖包</strong>：如 <code>node_modules/</code>，这个巨大的文件夹里装着几万个第三方依赖包，队友只需要运行安装命令就能重新下载，不需要上传。</li><li><strong>构建产物</strong>：如 <code>.next/</code> 或 <code>dist/</code>，这些是代码编译后生成的临时文件，没必要存档。</li><li><strong>系统垃圾</strong>：如 <code>.DS_Store</code>（Mac 系统的缓存文件）或 <code>Thumbs.db</code>（Windows 的缩略图缓存），上传了只会显得你不专业。</li><li><strong>错误日志</strong>：如 <code>npm-debug.log</code>，这是报错时的现场记录，通常也不需要共享。</li></ul><p>如果你真的手滑，在配置 <code>.gitignore</code> 之前就把敏感文件提交上去了，单纯的删除文件再提交是没用的，因为 Git 的历史记录里依然能查到。这时候，你可以求助 AI：<strong>“我不小心把密码提交到 Git 历史里了，请帮我写一段命令彻底清洗掉它。”</strong> AI 会指导你使用复杂的命令来修正错误。当然，为了绝对安全，清洗完记录后，最好还是去官网<strong>重置你的 Key</strong>。</p><p>既然 <code>.env</code> 被屏蔽了，以后队友拉下代码后怎么知道需要配置哪些变量呢？这就需要用到 <strong><code>.env.example</code></strong>。如果说 <code>.env</code> 是装着真钥匙的保险箱，那 <code>.env.example</code> 就是一个空的钥匙模具。你只在里面列出变量名（如 <code>DATABASE_URL=</code>），但不填具体的值。这个文件需要提交到 GitHub，队友拉取代码后，只需复制一份改名为 <code>.env</code>，然后填入自己的 Key，项目就能跑起来了。</p><p>配置好后，你马上就踩了一个大坑：你在 <code>.env</code> 里配置好了 Key，代码里也写好了调用逻辑，但程序依然报错说 <code>undefined</code> 或者出现一些奇怪的问题。你检查了拼写，检查了文件路径，甚至开始怀疑人生。最后老师傅淡淡地说了一句：“<strong>改了配置文件，要重启终端服务。</strong>” 你含泪杀掉终端进程（Ctrl+C）再运行 <code>pnpm dev</code>，一切正常。你深刻理解了环境变量配置的“生效滞后性”——因为环境变量是在程序启动的那一瞬间加载到内存里的，运行中修改文件，内存里的旧值是不会自动更新的。</p><p>随着 Next.js 开发的深入，你又遇到了一个诡异现象：你在 <code>.env</code> 里定义了 <code>API_KEY</code>，在服务器端（API Route）里能读到，但在前端组件（React Component）里打印出来却是 <code>undefined</code>。老师傅告诉你，这是 Next.js 为了防止你犯蠢而设计的<strong>安全机制</strong>，并顺便给你补习了 <strong>Server（服务端）</strong> 和 <strong>Client（客户端）</strong> 的概念。</p><ul><li><strong>Server（服务端）</strong>：通常指的是<strong>部署在云端的服务器</strong>（或者你本地启动的 Node.js 后台进程）。这里运行着你的后端代码，直接连接数据库。因为用户无法直接接触到这台机器的内部，所以在这里读取私钥（API Key）是非常安全的。默认情况下，<code>.env</code> 里的变量<strong>只在服务端可用</strong>。</li><li><strong>Client（客户端）</strong>：指的是<strong>用户的设备</strong>，比如用户电脑上的浏览器、手机上的 App。前端代码最终是运行在用户的手机或电脑里的。任何发送到客户端的数据，用户都可以通过技术手段（比如浏览器的 F12 开发者工具）查看到。如果在客户端把 API Key 暴露出来，就等于把保险箱密码贴在了大门上。</li></ul><p>所以，如果你真的需要在前端使用某些非敏感信息（比如网站标题、公开的 API 地址），你必须给变量名加上 <strong><code>NEXT_PUBLIC_</code></strong> 前缀（例如 <code>NEXT_PUBLIC_ANALYTICS_ID</code>）。只有带这个前缀的变量，构建工具才会允许它从安全的服务器端被发送到用户的设备上。</p><p>最后，你可能会问：上线后没有 <code>.env</code> 文件怎么办？老师傅告诉你，在后续的部署平台上，都有专门的环境变量设置页面。你只需要把本地 <code>.env</code> 里的内容一条条填进去即可。这就像是把钱从家里的保险箱（本地 <code>.env</code>）转移到了银行的保险箱（云端配置），虽然位置变了，但本质没变。</p>',14)])])}const v=o(c,[["render",r]]);export{_ as __pageData,v as default};
