import{_ as s,c as o,o as n,a3 as t}from"./chunks/framework.CUcrqFol.js";const m=JSON.parse('{"title":"第七章：数据持久化与数据库","description":"第七章：数据持久化与数据库 序言 界面搭建得有模有样了，但你发现一个尴尬的问题：每次刷新网页，刚才填写的表单、生成的对话全都不见了。 老师傅告诉你，这是因为浏览器里的数据默认只存储在临时的**内存**中。想要数据在关闭或刷新页面后依然存在，你需要**数据持久化**。 他严肃地提醒你：**数据是所有业务的基石**。前端代","frontmatter":{"title":"第七章：数据持久化与数据库"},"headers":[],"relativePath":"Advanced/07-data-persistence-database/index.md","filePath":"Advanced/07-data-persistence-database/index.md","lastUpdated":1766168364000}'),a={name:"Advanced/07-data-persistence-database/index.md"};function r(d,e,p,c,i,g){return n(),o("div",null,[...e[0]||(e[0]=[t(`<h1 id="第七章-数据持久化与数据库" tabindex="-1">第七章：数据持久化与数据库 <a class="header-anchor" href="#第七章-数据持久化与数据库" aria-label="Permalink to &quot;第七章：数据持久化与数据库&quot;">​</a></h1><h2 id="序言" tabindex="-1">序言 <a class="header-anchor" href="#序言" aria-label="Permalink to &quot;序言&quot;">​</a></h2><p>界面搭建得有模有样了，但你发现一个尴尬的问题：每次刷新网页，刚才填写的表单、生成的对话全都不见了。</p><p>老师傅告诉你，这是因为浏览器里的数据默认只存储在临时的<strong>内存</strong>中。想要数据在关闭或刷新页面后依然存在，你需要<strong>数据持久化</strong>。</p><p>他严肃地提醒你：<strong>数据是所有业务的基石</strong>。前端代码丢了可以重写，UI 丑了可以换皮，但如果数据库里的用户数据丢了、乱了，你的产品就彻底完了。这就是为什么后端开发往往比前端更注重严谨性——因为你守护的是产品的灵魂。</p><p>持久化不一定上来就要装复杂的软件。最简单的方式，其实就是把你之前在配置文件里学到的 <strong>JSON</strong> 格式利用起来，把数据存成 <code>.json</code> 文件。每一条聊天记录或用户信息，本质上就是一段文本。把它保存进硬盘的文件里，下次读取文件就能恢复。这种方式让你瞬间理解了“数据库”的本质——<strong>无非就是高效地读写硬盘上的文件。</strong></p><hr><p>虽然 JSON 文件简单，但当你数据多了，想找“所有住在北京且年龄大于 20 岁的用户”时，就需要遍历整个文件，效率极低。于是你接触到了 <strong>Relational Databases（关系型数据库）</strong>。老师傅让你把它想象成一个<strong>超级 Excel</strong>，理解它只需要掌握几个关键点：</p><ul><li><strong>Table (表)</strong>：就是一个 Excel Sheet（工作表），比如 <code>Users</code> 表。</li><li><strong>Row (行)</strong>：表里的一行，代表一条具体的数据（比如用户张三）。</li><li><strong>Column (列)</strong>：表里的表头，定义了数据有哪些属性（姓名、年龄、邮箱）。</li><li><strong>Primary Key (主键)</strong>：每一行数据的唯一身份证号（通常是 <code>id</code>），绝对不能重复。</li><li><strong>Foreign Key (外键)</strong>：用来关联其他表的线索。比如在 <code>Orders</code>（订单）表中记录一个 <code>user_id</code>，就能顺藤摸瓜找到这个订单属于哪个用户。</li></ul><p><strong>实战秘籍：如何判断 AI 设计的表结构好坏？</strong> 新手往往很难一眼看出 Schema 设计得合不合理。老师傅传授了你一招**“AI 交叉论证法”**（俗称“炼蛊”）：你让 ChatGPT 帮你设计好表结构，然后把生成的代码发给 Claude 或 Deepseek，问它：“<strong>作为一个资深数据库架构师，请批判一下这个设计有什么潜在的性能隐患或逻辑漏洞？</strong>” 通常经过两轮这样的“左右互搏”，你就能得到一个非常健壮的数据库模型。</p><hr><p>就像你用 JavaScript 指挥浏览器一样，指挥数据库也有专门的语言，叫 <strong>SQL</strong>。但在 Vibecoding 中，你不需要专门去学 SQL，因为我们有 <strong>Prisma</strong>。你只需要看懂它的“蓝图文件”——<code>schema.prisma</code>。</p><p>你可能会问，这个复杂的文件是谁写的？是你需要背诵语法然后一个字一个字敲出来的吗？当然不是。它是 <strong>AI 从你的 PRD 文档里“悟”出来的</strong>。当你在 PRD 里写下“一个用户可以发布多篇文章”时，AI 读懂了这层业务逻辑，于是它自动在 <code>User</code> 表里加上了 <code>posts</code> 字段，在 <code>Post</code> 表里加上了 <code>authorId</code> 字段。<strong>你的工作不是写代码，而是检查 AI 是否正确理解了你的意图。</strong></p><p>为了能看懂 AI 交的作业，老师傅指着一段代码，逐行教你认字：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model User {</span></span>
<span class="line"><span>  id        Int      @id @default(autoincrement())  // 整数类型，作为主键，自动+1</span></span>
<span class="line"><span>  email     String   @unique                        // 字符串类型，必须唯一</span></span>
<span class="line"><span>  name      String?                                 // 字符串类型，但在类型后面加了问号，表示“可选项”（可以不填）</span></span>
<span class="line"><span>  createdAt DateTime @default(now())                // 时间类型，默认填入当前时间</span></span>
<span class="line"><span>  posts     Post[]                                  // 关联关系：一个用户可以有多篇文章</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong><code>model</code></strong>：这就代表一张<strong>表</strong>。</li><li><strong>类型</strong>：<code>Int</code>（整数）、<code>String</code>（文本）、<code>Boolean</code>（真假）、<code>DateTime</code>（时间）。</li><li><strong><code>?</code>（问号）</strong>：这是新手的救星。它代表 <strong>Optional（可选）</strong>。如果你不确定一个字段是不是必填的（比如用户的“个人简介”），加上问号，数据库就允许它为空，否则一旦没填程序就会报错。</li><li><strong><code>@unique</code></strong>：代表这个内容（如邮箱）全表唯一，不能重复注册。</li></ul><p>虽然不用写 SQL，但你必须把 <strong>CRUD</strong>（Create 增、Read 查、Update 改、Delete 删）刻在脑子里。<strong>这是所有数据库操作的基石，也是你指挥 AI 操作数据的核心通用术语。</strong></p><hr><p>为了实战，你接触到了 <strong>SQLite</strong>，它是一个轻量级的文件数据库，不需要安装，非常适合开发测试。但为了未来的扩展性，老师傅建议你使用 <strong>PostgreSQL</strong>。</p><p>为什么是 PostgreSQL？除了它是世界上最强大的开源关系型数据库之一，它还有两个让 AI 开发者无法拒绝的特性：</p><ol><li><strong>JSONB 支持</strong>：它虽然是关系型数据库，但能像 NoSQL 一样直接存 JSON 数据。这意味着你可以把 AI 生成的那些结构不确定的复杂数据直接丢进去，既有规则（SQL）又有灵活性（NoSQL）。</li><li><strong>pgvector（向量检索）</strong>：这是 AI 时代的杀手锏。它可以存储和查询“向量数据”，这是实现 <strong>AI 长期记忆</strong>（RAG）的核心技术。选了 PostgreSQL，就等于为你的 AI 应用铺平了未来的路。</li></ol><p>在实操中，有两个新手必踩的坑：</p><p><strong>坑一：Connection URL（连接字符串）</strong> 你经常看到 <code>Error: Invalid URL</code> 的报错。老师傅告诉你，连接数据库就像寄信，格式必须严格遵守：<code>postgresql://用户名:密码@主机地址:端口/数据库名</code>。任何一个标点符号错了，或者密码里包含了特殊字符（需要转义），都会导致连接失败。</p><p><strong>坑二：Schema 与代码不同步（最重要的命令）</strong> 你让 AI 在数据库里增加了一个 <code>phone</code> 字段，AI 修改了 <code>schema.prisma</code> 文件。但当你运行代码时，程序却炸了，提示“User 上不存在 phone 属性”。你开始怀疑人生，老师傅却淡定地让你运行一句命令：<code>npx prisma generate</code>。</p><p>原来，Prisma 为了保证 TypeScript 的类型安全，需要根据 Schema 生成一份“类型定义文件”。<strong>每当你修改了数据库结构（Schema），都必须重新运行 generate 命令</strong>，告诉代码：“嘿，数据库结构变了，请更新你的认知。”</p><p>老师傅特意叮嘱：<strong>这个命令非常重要，以至于在未来你部署上线时（比如在 Vercel 的 Build Command 里），也必须把它加进去</strong>，否则线上的代码会因为不认识新的数据库结构而报错。</p>`,26)])])}const h=s(a,[["render",r]]);export{m as __pageData,h as default};
