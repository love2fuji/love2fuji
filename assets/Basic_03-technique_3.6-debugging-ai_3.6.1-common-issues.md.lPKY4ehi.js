import{_ as a,c as i,o as t,a3 as n}from"./chunks/framework.CUcrqFol.js";const g=JSON.parse('{"title":"3.6.1 AI 常见的\\"不听话\\"表现","description":"3.6.1 AI 常见的「不听话」表现 经过本节学习，你将掌握 识别 AI 输出问题的六种常见类型 理解 AI 幻觉的四种形态及其危害 了解 2024-2025 年新兴的「Slopsquatting」安全威胁 获得一份实用的验证技巧速查表 六种常见问题类型 AI 的「不听话」表现看似五花八门，但归纳起来主要有六种类型：","frontmatter":{"title":"3.6.1 AI 常见的\\"不听话\\"表现"},"headers":[],"relativePath":"Basic/03-technique/3.6-debugging-ai/3.6.1-common-issues.md","filePath":"Basic/03-technique/3.6-debugging-ai/3.6.1-common-issues.md","lastUpdated":1765094268000}'),l={name:"Basic/03-technique/3.6-debugging-ai/3.6.1-common-issues.md"};function e(h,s,p,r,o,d){return t(),i("div",null,[...s[0]||(s[0]=[n(`<h1 id="_3-6-1-ai-常见的「不听话」表现" tabindex="-1">3.6.1 AI 常见的「不听话」表现 <a class="header-anchor" href="#_3-6-1-ai-常见的「不听话」表现" aria-label="Permalink to &quot;3.6.1 AI 常见的「不听话」表现&quot;">​</a></h1><h2 id="经过本节学习-你将掌握" tabindex="-1">经过本节学习，你将掌握 <a class="header-anchor" href="#经过本节学习-你将掌握" aria-label="Permalink to &quot;经过本节学习，你将掌握&quot;">​</a></h2><ul><li>识别 AI 输出问题的六种常见类型</li><li>理解 AI 幻觉的四种形态及其危害</li><li>了解 2024-2025 年新兴的「Slopsquatting」安全威胁</li><li>获得一份实用的验证技巧速查表</li></ul><h2 id="六种常见问题类型" tabindex="-1">六种常见问题类型 <a class="header-anchor" href="#六种常见问题类型" aria-label="Permalink to &quot;六种常见问题类型&quot;">​</a></h2><p>AI 的「不听话」表现看似五花八门，但归纳起来主要有六种类型：</p><table tabindex="0"><thead><tr><th>类型</th><th>症状</th><th>典型案例</th></tr></thead><tbody><tr><td><strong>答非所问</strong></td><td>AI 理解错了你的意图</td><td>你要登录页，它给了注册页</td></tr><tr><td><strong>过度发挥</strong></td><td>做了你没要求的事情</td><td>你要简单时钟，它给了带时区切换的全功能版</td></tr><tr><td><strong>偷工减料</strong></td><td>少做了关键部分</td><td>没有错误处理，缺少边界检查</td></tr><tr><td><strong>自相矛盾</strong></td><td>前后逻辑不一致</td><td>注释说「返回数组」，代码实际返回对象</td></tr><tr><td><strong>幻觉</strong></td><td>编造不存在的内容</td><td>推荐不存在的库，调用不存在的 API</td></tr><tr><td><strong>死循环</strong></td><td>反复犯同一个错误</td><td>你指出问题，它改了，下次又改回去</td></tr></tbody></table><h3 id="类型一-答非所问" tabindex="-1">类型一：答非所问 <a class="header-anchor" href="#类型一-答非所问" aria-label="Permalink to &quot;类型一：答非所问&quot;">​</a></h3><p><strong>场景</strong>：你让 AI 做一个「用户登录功能」，它却给了你完整的「用户注册 + 登录 + 找回密码」三件套。</p><p><strong>为什么会这样</strong>：AI 基于大量训练数据进行模式匹配，当它看到「登录」这个词时，会联想到常见的用户认证系统，然后「好心」地给你全套方案。</p><p><strong>识别信号</strong>：</p><ul><li>输出的内容比你要的多很多</li><li>包含了你没提到的功能模块</li><li>AI 在解释时说「我假设你还需要...」</li></ul><h3 id="类型二-过度发挥" tabindex="-1">类型二：过度发挥 <a class="header-anchor" href="#类型二-过度发挥" aria-label="Permalink to &quot;类型二：过度发挥&quot;">​</a></h3><p><strong>场景</strong>：你只想要一个显示当前时间的简单组件，AI 却加上了时区选择、12/24 小时切换、自定义格式等功能。</p><p><strong>为什么会这样</strong>：AI 见过太多「完整」的解决方案，倾向于给出「全面」的实现，即使你只需要最简单的版本。</p><p><strong>识别信号</strong>：</p><ul><li>代码量远超预期</li><li>引入了你不认识的第三方库</li><li>包含大量你不需要的配置选项</li></ul><h3 id="类型三-偷工减料" tabindex="-1">类型三：偷工减料 <a class="header-anchor" href="#类型三-偷工减料" aria-label="Permalink to &quot;类型三：偷工减料&quot;">​</a></h3><p><strong>场景</strong>：AI 给的代码能跑，但没有处理「用户输入为空」「网络请求失败」等异常情况。</p><p><strong>为什么会这样</strong>：为了让代码看起来简洁，或者因为你没有明确要求，AI 省略了防御性代码。</p><p><strong>识别信号</strong>：</p><ul><li>代码中没有 try-catch 或错误处理</li><li>没有输入验证</li><li>「Happy Path」（理想路径）能跑，边界情况会崩</li></ul><h3 id="类型四-自相矛盾" tabindex="-1">类型四：自相矛盾 <a class="header-anchor" href="#类型四-自相矛盾" aria-label="Permalink to &quot;类型四：自相矛盾&quot;">​</a></h3><p><strong>场景</strong>：AI 说「这个函数返回用户列表」，但实际代码返回的是单个用户对象。</p><p><strong>为什么会这样</strong>：AI 生成注释和生成代码是相对独立的过程，有时会出现不同步。</p><p><strong>识别信号</strong>：</p><ul><li>注释与代码行为不符</li><li>函数名暗示的功能与实际实现不一致</li><li>前面说的方案和后面的代码不匹配</li></ul><h3 id="类型五-幻觉-重点" tabindex="-1">类型五：幻觉（重点） <a class="header-anchor" href="#类型五-幻觉-重点" aria-label="Permalink to &quot;类型五：幻觉（重点）&quot;">​</a></h3><p>这是最危险的问题类型，下面会详细展开。</p><h3 id="类型六-死循环" tabindex="-1">类型六：死循环 <a class="header-anchor" href="#类型六-死循环" aria-label="Permalink to &quot;类型六：死循环&quot;">​</a></h3><p><strong>场景</strong>：你指出代码有问题，AI 修改后，下一轮又改回了原来的写法。</p><p><strong>为什么会这样</strong>：</p><ul><li>对话上下文太长，AI「忘记」了前面的修正</li><li>你的修正指令不够明确</li><li>任务本身超出了 AI 的能力范围</li></ul><p><strong>识别信号</strong>：</p><ul><li>同样的错误反复出现</li><li>AI 的修改越来越「绕」</li><li>修一个问题引入两个新问题</li></ul><h2 id="重点-ai-幻觉的识别与应对" tabindex="-1">重点：AI 幻觉的识别与应对 <a class="header-anchor" href="#重点-ai-幻觉的识别与应对" aria-label="Permalink to &quot;重点：AI 幻觉的识别与应对&quot;">​</a></h2><p>AI 幻觉（Hallucination）是指 AI 生成<strong>看起来正确但实际错误</strong>的内容。在编程场景中，这可能导致代码无法运行，甚至引入安全漏洞。</p><h3 id="代码幻觉的四种类型" tabindex="-1">代码幻觉的四种类型 <a class="header-anchor" href="#代码幻觉的四种类型" aria-label="Permalink to &quot;代码幻觉的四种类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>表现</th><th>危害程度</th><th>示例</th></tr></thead><tbody><tr><td><strong>包幻觉</strong></td><td>推荐不存在的 npm/pip 包</td><td>🔴 高（安全风险）</td><td><code>npm install super-easy-utils</code>（包不存在）</td></tr><tr><td><strong>API 幻觉</strong></td><td>编造不存在的函数或方法</td><td>🟡 中</td><td>调用 <code>array.findLast()</code> 在旧版 JS 中不存在</td></tr><tr><td><strong>逻辑幻觉</strong></td><td>代码逻辑与描述不符</td><td>🟡 中</td><td>说「返回去重后的数组」，实际没有去重</td></tr><tr><td><strong>版本幻觉</strong></td><td>使用已废弃的语法或 API</td><td>🟡 中</td><td>使用 React 旧版类组件生命周期</td></tr></tbody></table><h3 id="包幻觉-最危险的幻觉类型" tabindex="-1">包幻觉：最危险的幻觉类型 <a class="header-anchor" href="#包幻觉-最危险的幻觉类型" aria-label="Permalink to &quot;包幻觉：最危险的幻觉类型&quot;">​</a></h3><p>为什么包幻觉的危害程度最高？因为它涉及到<strong>软件供应链安全</strong>。</p><p><strong>真实案例</strong>：2024-2025 年的安全研究发现了一种名为「Slopsquatting」的攻击方式：</p><ol><li>研究人员测试了 16 种主流 AI 模型，发现它们推荐的包中约 <strong>20% 是不存在的</strong></li><li>更令人担忧的是，<strong>43% 的幻觉包名会在多次询问中重复出现</strong></li><li>攻击者可以注册这些 AI 经常「幻觉」出的包名，植入恶意代码</li><li>当开发者按 AI 建议安装这些包时，就会中招</li></ol><p><strong>攻击链条</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AI 幻觉出包名 → 攻击者注册该包名 → 植入恶意代码 → 开发者按 AI 建议安装 → 系统被入侵</span></span></code></pre></div><p><strong>真实威胁</strong>：2025 年 10 月，安全公司发现了名为「PhantomRaven」的恶意活动，利用这种技术感染了 126 个 npm 包，窃取了开发者的 npm tokens、GitHub 凭证等敏感信息。</p><h3 id="api-幻觉-看起来对但跑不起来" tabindex="-1">API 幻觉：看起来对但跑不起来 <a class="header-anchor" href="#api-幻觉-看起来对但跑不起来" aria-label="Permalink to &quot;API 幻觉：看起来对但跑不起来&quot;">​</a></h3><p><strong>典型场景</strong>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// AI 生成的代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lastItem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findLast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.active);</span></span></code></pre></div><p>问题：<code>findLast()</code> 是 ES2023 引入的方法，在旧版浏览器或 Node.js 中不可用。AI 可能混淆了不同版本的 API。</p><p><strong>常见的 API 幻觉模式</strong>：</p><ul><li>混淆不同库的 API（把 Lodash 的方法当成原生方法）</li><li>使用已废弃的 API</li><li>编造不存在的配置选项</li></ul><h3 id="逻辑幻觉-代码能跑但结果不对" tabindex="-1">逻辑幻觉：代码能跑但结果不对 <a class="header-anchor" href="#逻辑幻觉-代码能跑但结果不对" aria-label="Permalink to &quot;逻辑幻觉：代码能跑但结果不对&quot;">​</a></h3><p><strong>典型场景</strong>：</p><p>你让 AI 写一个「去重函数」，它给了你：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeDuplicates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 去除数组中的重复元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>代码看起来没问题，注释也对。但如果数组中包含对象，这个方法就失效了，因为对象比较的是引用而不是值。</p><h3 id="版本幻觉-用的是「过时」的写法" tabindex="-1">版本幻觉：用的是「过时」的写法 <a class="header-anchor" href="#版本幻觉-用的是「过时」的写法" aria-label="Permalink to &quot;版本幻觉：用的是「过时」的写法&quot;">​</a></h3><p><strong>典型场景</strong>：</p><p>你让 AI 用 React 写一个组件，它给了你类组件写法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  componentWillMount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>问题：<code>componentWillMount</code> 在 React 16.3 后已被废弃，React 18 中会产生警告。</p><h2 id="验证技巧速查表" tabindex="-1">验证技巧速查表 <a class="header-anchor" href="#验证技巧速查表" aria-label="Permalink to &quot;验证技巧速查表&quot;">​</a></h2><p>面对 AI 生成的代码，用这份清单快速验证：</p><h3 id="验证包是否存在" tabindex="-1">验证包是否存在 <a class="header-anchor" href="#验证包是否存在" aria-label="Permalink to &quot;验证包是否存在&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># npm 包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> search</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">包</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 或直接访问 https://www.npmjs.com/package/&lt;包名&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Python 包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> versions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">包</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 或直接访问 https://pypi.org/project/&lt;包名&gt;</span></span></code></pre></div><h3 id="验证-api-是否正确" tabindex="-1">验证 API 是否正确 <a class="header-anchor" href="#验证-api-是否正确" aria-label="Permalink to &quot;验证 API 是否正确&quot;">​</a></h3><ol><li><strong>查阅官方文档</strong>：不要只相信 AI 的解释</li><li><strong>检查兼容性</strong>：使用 <a href="https://caniuse.com" target="_blank" rel="noreferrer">caniuse.com</a>（前端）或查看库的版本说明</li><li><strong>小范围测试</strong>：先在独立环境跑一下，确认能用</li></ol><h3 id="要求-ai-提供来源" tabindex="-1">要求 AI 提供来源 <a class="header-anchor" href="#要求-ai-提供来源" aria-label="Permalink to &quot;要求 AI 提供来源&quot;">​</a></h3><p>当 AI 推荐了你不熟悉的库或 API 时，追问：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请给出这个库的官方文档链接。</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>这个 API 是在哪个版本引入的？请给出参考来源。</span></span></code></pre></div><p>如果 AI 无法给出有效链接，或者链接打开是 404，那很可能是幻觉。</p><h3 id="验证逻辑正确性" tabindex="-1">验证逻辑正确性 <a class="header-anchor" href="#验证逻辑正确性" aria-label="Permalink to &quot;验证逻辑正确性&quot;">​</a></h3><ol><li><strong>用边界情况测试</strong>：空数组、空字符串、null、超大数值</li><li><strong>用反例测试</strong>：故意输入「应该失败」的数据，看是否正确处理</li><li><strong>让 AI 自己检查</strong>：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请检查上面的代码，列出可能的边界情况和异常情况，以及当前代码是否正确处理了它们。</span></span></code></pre></div></li></ol><h2 id="本节要点" tabindex="-1">本节要点 <a class="header-anchor" href="#本节要点" aria-label="Permalink to &quot;本节要点&quot;">​</a></h2><p>✓ <strong>六种问题类型</strong>：答非所问、过度发挥、偷工减料、自相矛盾、幻觉、死循环</p><p>✓ <strong>四种代码幻觉</strong>：包幻觉（最危险）、API 幻觉、逻辑幻觉、版本幻觉</p><p>✓ <strong>Slopsquatting 威胁</strong>：攻击者利用 AI 幻觉的包名进行供应链攻击，20% 的 AI 推荐包可能不存在</p><p>✓ <strong>验证习惯</strong>：对 AI 推荐的包和 API，先验证再使用；对代码逻辑，用边界情况测试</p><p>识别问题只是第一步。下一节，我们来学习如何快速定位问题的根源。</p>`,80)])])}const c=a(l,[["render",e]]);export{g as __pageData,c as default};
