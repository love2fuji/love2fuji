import{_ as a,c as o,o as i,a3 as l}from"./chunks/framework.CUcrqFol.js";const u=JSON.parse('{"title":"5.1.1 一个真实的噩梦场景","description":"5.1.1 一个真实的噩梦场景 这种经历，每个学习者都会遇到 想象一下这个场景： 你花了 2 小时，终于做好了待办清单 页面很漂亮，功能也正常，你很有成就感 想再加个\\"深色模式\\"功能，让它更炫酷 改着改着，页面突然白屏了 你不记得改了哪里，Ctrl+Z 也按不回去 2 小时的成果，就这样没了... 这不是夸张。在社区里","frontmatter":{"title":"5.1.1 一个真实的噩梦场景","order":2},"headers":[],"relativePath":"Basic/05-advanced/5.1-version-control/5.1.1-nightmare.md","filePath":"Basic/05-advanced/5.1-version-control/5.1.1-nightmare.md","lastUpdated":1765094268000}'),r={name:"Basic/05-advanced/5.1-version-control/5.1.1-nightmare.md"};function e(d,t,n,s,h,p){return i(),o("div",null,[...t[0]||(t[0]=[l('<h1 id="_5-1-1-一个真实的噩梦场景" tabindex="-1">5.1.1 一个真实的噩梦场景 <a class="header-anchor" href="#_5-1-1-一个真实的噩梦场景" aria-label="Permalink to &quot;5.1.1 一个真实的噩梦场景&quot;">​</a></h1><h2 id="这种经历-每个学习者都会遇到" tabindex="-1">这种经历，每个学习者都会遇到 <a class="header-anchor" href="#这种经历-每个学习者都会遇到" aria-label="Permalink to &quot;这种经历，每个学习者都会遇到&quot;">​</a></h2><p>想象一下这个场景：</p><ol><li>你花了 2 小时，终于做好了待办清单</li><li>页面很漂亮，功能也正常，你很有成就感</li><li>想再加个&quot;深色模式&quot;功能，让它更炫酷</li><li>改着改着，页面突然白屏了</li><li>你不记得改了哪里，Ctrl+Z 也按不回去</li><li>2 小时的成果，就这样没了...</li></ol><p>这不是夸张。在社区里，几乎每周都能看到类似的求助帖：&quot;我的代码改崩了，怎么恢复？&quot;</p><h2 id="更常见的几种情况" tabindex="-1">更常见的几种情况 <a class="header-anchor" href="#更常见的几种情况" aria-label="Permalink to &quot;更常见的几种情况&quot;">​</a></h2><table tabindex="0"><thead><tr><th>场景</th><th>发生了什么</th><th>后果</th></tr></thead><tbody><tr><td>改一个功能，坏了另一个</td><td>添加删除功能时，不小心影响了添加功能</td><td>花时间排查，可能越改越乱</td></tr><tr><td>想回到&quot;昨天那个版本&quot;</td><td>昨天的代码能用，今天改了一堆，全坏了</td><td>找不到昨天的版本</td></tr><tr><td>试了三种方案，想回到第一种</td><td>第一种方案其实最好，但已经被覆盖了</td><td>要么重写，要么将就</td></tr><tr><td>AI 改了不该改的地方</td><td>让 AI 改一个文件，它顺手改了其他文件</td><td>不知道哪些被改了</td></tr></tbody></table><h2 id="为什么会发生这种事" tabindex="-1">为什么会发生这种事 <a class="header-anchor" href="#为什么会发生这种事" aria-label="Permalink to &quot;为什么会发生这种事&quot;">​</a></h2><p>Vibe Coding 的工作方式是：你告诉 AI 想要什么，AI 直接修改代码。</p><p>这个过程非常高效，但有一个风险：<strong>改动是即时的、覆盖式的</strong>。</p><p>传统程序员有一套复杂的工具来管理代码历史，但对于刚入门的你，这些工具学习成本太高。</p><p>好消息是：你不需要学那些复杂的东西。</p><h2 id="解决方案-给代码装上-时光机" tabindex="-1">解决方案：给代码装上&quot;时光机&quot; <a class="header-anchor" href="#解决方案-给代码装上-时光机" aria-label="Permalink to &quot;解决方案：给代码装上&quot;时光机&quot;&quot;">​</a></h2><p><strong>版本管理</strong>，本质上就是给你的代码创建&quot;存档点&quot;。</p><p>就像玩游戏时的存档功能：</p><ul><li>打 Boss 之前存一个档</li><li>打输了可以读档重来</li><li>试新技能之前存一个档</li><li>不好用可以回退</li></ul><p>代码也是一样：</p><ul><li>功能做好了存一个档</li><li>准备大改之前存一个档</li><li>改崩了可以回退</li></ul><div class="tip custom-block"><p class="custom-block-title">核心观点</p><p>版本管理不是高级技能，是基本生存技能。</p><p>你不需要成为 Git 专家。只需要知道：<strong>怎么存档、怎么读档</strong>，就够了。</p></div><h2 id="接下来学什么" tabindex="-1">接下来学什么 <a class="header-anchor" href="#接下来学什么" aria-label="Permalink to &quot;接下来学什么&quot;">​</a></h2><p>我们会介绍三种方案，从简单到进阶：</p><ol><li><strong>AI IDE 自带的历史功能</strong>：最简单，立即可用</li><li><strong>手动复制文件夹</strong>：最直观，人人都会</li><li><strong>GitHub Desktop</strong>：更专业，为进阶版打基础</li></ol><p>先从最简单的开始。</p><p>→ <a href="./5.1.2-ide-history.html">5.1.2 零门槛方案：AI IDE 自带历史</a></p>',24)])])}const _=a(r,[["render",e]]);export{u as __pageData,_ as default};
