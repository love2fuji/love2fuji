import{_ as e,C as l,c as h,o as i,a3 as a,b as k,w as t,a as p,G as E,a4 as r}from"./chunks/framework.CUcrqFol.js";const C=JSON.parse('{"title":"12.3.1 AI 应用的核心模式——流式响应原理：为什么需要 Streaming UI","description":"12.3.1 AI 应用的核心模式——流式响应原理：为什么需要 Streaming UI 一句话破题 流式响应让 AI 的回答像\\"打字机\\"一样逐字出现，将用户的等待焦虑转化为阅读体验，这是现代 AI 应用的核心交互模式。 认知重构：为什么等待 5 秒感觉像 50 秒 当你向 ChatGPT 提问时，模型实际上是**逐个","frontmatter":{"title":"12.3.1 AI 应用的核心模式——流式响应原理：为什么需要 Streaming UI","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/12-advanced/12.3-vercel-ai-sdk/12.3.1-streaming-ui.md","filePath":"Advanced-old/12-advanced/12.3-vercel-ai-sdk/12.3.1-streaming-ui.md","lastUpdated":1766168364000}'),d={name:"Advanced-old/12-advanced/12.3-vercel-ai-sdk/12.3.1-streaming-ui.md"};function o(g,s,c,A,F,y){const n=l("Mermaid");return i(),h("div",null,[s[1]||(s[1]=a('<h1 id="_12-3-1-ai-应用的核心模式——流式响应原理-为什么需要-streaming-ui" tabindex="-1">12.3.1 AI 应用的核心模式——流式响应原理：为什么需要 Streaming UI <a class="header-anchor" href="#_12-3-1-ai-应用的核心模式——流式响应原理-为什么需要-streaming-ui" aria-label="Permalink to &quot;12.3.1 AI 应用的核心模式——流式响应原理：为什么需要 Streaming UI&quot;">​</a></h1><h3 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h3><p>流式响应让 AI 的回答像&quot;打字机&quot;一样逐字出现，将用户的等待焦虑转化为阅读体验，这是现代 AI 应用的核心交互模式。</p><h3 id="认知重构-为什么等待-5-秒感觉像-50-秒" tabindex="-1">认知重构：为什么等待 5 秒感觉像 50 秒 <a class="header-anchor" href="#认知重构-为什么等待-5-秒感觉像-50-秒" aria-label="Permalink to &quot;认知重构：为什么等待 5 秒感觉像 50 秒&quot;">​</a></h3><p>当你向 ChatGPT 提问时，模型实际上是<strong>逐个 Token 生成</strong>答案的。传统的 HTTP 请求会等待所有 Token 生成完毕后才返回，这意味着：</p><ul><li>用户需要盯着空白屏幕等待数秒</li><li>如果回答很长，等待时间可能超过 10 秒</li><li>用户无法判断请求是否卡住了</li></ul><p>流式响应的做法是：<strong>一边生成，一边返回</strong>。</p><h3 id="本质还原-传统响应-vs-流式响应" tabindex="-1">本质还原：传统响应 vs 流式响应 <a class="header-anchor" href="#本质还原-传统响应-vs-流式响应" aria-label="Permalink to &quot;本质还原：传统响应 vs 流式响应&quot;">​</a></h3>',8)),(i(),k(r,null,{default:t(()=>[E(n,{id:"mermaid-38",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20U%20as%20%E7%94%A8%E6%88%B7%0A%20%20%20%20participant%20S%20as%20%E6%9C%8D%E5%8A%A1%E5%99%A8%0A%20%20%20%20participant%20AI%20as%20AI%20%E6%A8%A1%E5%9E%8B%0A%20%20%20%20%0A%20%20%20%20rect%20rgb(255%2C%20230%2C%20230)%0A%20%20%20%20%20%20%20%20Note%20over%20U%2CAI%3A%20%E4%BC%A0%E7%BB%9F%E5%93%8D%E5%BA%94%EF%BC%88%E4%B8%80%E6%AC%A1%E6%80%A7%E8%BF%94%E5%9B%9E%EF%BC%89%0A%20%20%20%20%20%20%20%20U-%3E%3ES%3A%20%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98%0A%20%20%20%20%20%20%20%20S-%3E%3EAI%3A%20%E8%AF%B7%E6%B1%82%E7%94%9F%E6%88%90%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20%E7%94%9F%E6%88%90%20Token%201%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20%E7%94%9F%E6%88%90%20Token%202%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20...%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20%E7%94%9F%E6%88%90%20Token%20N%0A%20%20%20%20%20%20%20%20S-%3E%3EU%3A%20%E8%BF%94%E5%9B%9E%E5%AE%8C%E6%95%B4%E7%AD%94%E6%A1%88%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20rect%20rgb(230%2C%20255%2C%20230)%0A%20%20%20%20%20%20%20%20Note%20over%20U%2CAI%3A%20%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%EF%BC%88%E8%BE%B9%E7%94%9F%E6%88%90%E8%BE%B9%E8%BF%94%E5%9B%9E%EF%BC%89%0A%20%20%20%20%20%20%20%20U-%3E%3ES%3A%20%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98%0A%20%20%20%20%20%20%20%20S-%3E%3EAI%3A%20%E8%AF%B7%E6%B1%82%E7%94%9F%E6%88%90%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20Token%201%0A%20%20%20%20%20%20%20%20S--%3E%3EU%3A%20Token%201%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20Token%202%0A%20%20%20%20%20%20%20%20S--%3E%3EU%3A%20Token%202%0A%20%20%20%20%20%20%20%20AI--%3E%3ES%3A%20Token%20N%0A%20%20%20%20%20%20%20%20S--%3E%3EU%3A%20Token%20N%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...s[0]||(s[0]=[p(" Loading... ",-1)])]),_:1})),s[2]||(s[2]=a(`<h3 id="技术实现-server-sent-events" tabindex="-1">技术实现：Server-Sent Events <a class="header-anchor" href="#技术实现-server-sent-events" aria-label="Permalink to &quot;技术实现：Server-Sent Events&quot;">​</a></h3><p>流式响应通常基于 <strong>Server-Sent Events (SSE)</strong> 或 <strong>WebSocket</strong> 实现。Vercel AI SDK 默认使用 SSE：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务端发送的格式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;你&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;好&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>客户端通过 <code>EventSource</code> 或 <code>fetch</code> + <code>ReadableStream</code> 接收：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/chat&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> decoder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextDecoder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">done</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (done) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> decoder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 逐步输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="用户体验的质变" tabindex="-1">用户体验的质变 <a class="header-anchor" href="#用户体验的质变" aria-label="Permalink to &quot;用户体验的质变&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指标</th><th>传统响应</th><th>流式响应</th></tr></thead><tbody><tr><td>首字节时间</td><td>5-10 秒</td><td>&lt; 1 秒</td></tr><tr><td>感知等待时间</td><td>很长</td><td>几乎无感</td></tr><tr><td>中断能力</td><td>无法中断</td><td>可随时停止</td></tr><tr><td>错误反馈</td><td>超时后才知道</td><td>实时感知</td></tr></tbody></table><h3 id="流式响应的挑战" tabindex="-1">流式响应的挑战 <a class="header-anchor" href="#流式响应的挑战" aria-label="Permalink to &quot;流式响应的挑战&quot;">​</a></h3><p>虽然流式响应体验更好，但也带来了一些技术挑战：</p><ol><li><strong>状态管理</strong>：需要追踪&quot;正在生成&quot;、&quot;已完成&quot;、&quot;发生错误&quot;等状态</li><li><strong>错误处理</strong>：流式传输中途出错如何恢复？</li><li><strong>渲染性能</strong>：频繁更新 DOM 可能导致卡顿</li><li><strong>取消机制</strong>：用户中途取消如何优雅处理？</li></ol><p>这些问题，Vercel AI SDK 都提供了解决方案。</p><h3 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h3><ul><li><strong>核心意图</strong>：让 AI 帮你理解或实现流式响应的底层机制。</li><li><strong>需求定义公式</strong>：<code>&quot;请解释 Server-Sent Events 如何工作，并给出一个 Next.js 中实现流式 AI 响应的基础示例。&quot;</code></li><li><strong>关键术语</strong>：<code>SSE</code>、<code>ReadableStream</code>、<code>TextDecoder</code>、<code>流式传输 (streaming)</code></li></ul><h3 id="避坑指南" tabindex="-1">避坑指南 <a class="header-anchor" href="#避坑指南" aria-label="Permalink to &quot;避坑指南&quot;">​</a></h3><ul><li><strong>不要忘记处理连接中断</strong>：网络不稳定时，流可能意外关闭。</li><li><strong>注意内存管理</strong>：长时间的流式响应可能累积大量数据。</li><li><strong>测试弱网环境</strong>：流式响应在弱网下可能表现异常。</li></ul>`,15))])}const B=e(d,[["render",o]]);export{C as __pageData,B as default};
