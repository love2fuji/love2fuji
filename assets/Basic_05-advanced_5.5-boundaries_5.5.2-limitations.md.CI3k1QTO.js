import{_ as d,c as o,o as a,a3 as r}from"./chunks/framework.CUcrqFol.js";const q=JSON.parse('{"title":"5.5.2 Vibe Coding 的局限性","description":"5.5.2 Vibe Coding 的局限性 经过本节学习，你将了解： Vibe Coding 不擅长的五大场景 \\"70% 问题\\"和\\"80% 墙\\"是什么 为什么知道局限性反而让你更有信心 先看数据：AI 生成的代码并不完美 这些是 2025 年的真实数据，不是为了吓你，而是帮你建立正确预期： | 数据 | 来源 | 含","frontmatter":{"title":"5.5.2 Vibe Coding 的局限性","order":3},"headers":[],"relativePath":"Basic/05-advanced/5.5-boundaries/5.5.2-limitations.md","filePath":"Basic/05-advanced/5.5-boundaries/5.5.2-limitations.md","lastUpdated":1765094268000}'),i={name:"Basic/05-advanced/5.5-boundaries/5.5.2-limitations.md"};function e(l,t,n,u,h,s){return a(),o("div",null,[...t[0]||(t[0]=[r('<h1 id="_5-5-2-vibe-coding-的局限性" tabindex="-1">5.5.2 Vibe Coding 的局限性 <a class="header-anchor" href="#_5-5-2-vibe-coding-的局限性" aria-label="Permalink to &quot;5.5.2 Vibe Coding 的局限性&quot;">​</a></h1><p>经过本节学习，你将了解：</p><ul><li>Vibe Coding 不擅长的五大场景</li><li>&quot;70% 问题&quot;和&quot;80% 墙&quot;是什么</li><li>为什么知道局限性反而让你更有信心</li></ul><h2 id="先看数据-ai-生成的代码并不完美" tabindex="-1">先看数据：AI 生成的代码并不完美 <a class="header-anchor" href="#先看数据-ai-生成的代码并不完美" aria-label="Permalink to &quot;先看数据：AI 生成的代码并不完美&quot;">​</a></h2><p>这些是 2025 年的真实数据，不是为了吓你，而是帮你建立正确预期：</p><table tabindex="0"><thead><tr><th>数据</th><th>来源</th><th>含义</th></tr></thead><tbody><tr><td><strong>45%</strong> 的 AI 生成代码未通过安全测试</td><td>Veracode 2025</td><td>将近一半的代码有安全隐患</td></tr><tr><td><strong>46%</strong> 的开发者不完全信任 AI 生成的代码</td><td>Index.dev 2025</td><td>专业开发者也保持谨慎</td></tr><tr><td>过度依赖 AI 导致 bug 增加 <strong>41%</strong></td><td>Index.dev 2025</td><td>不检查就用会出问题</td></tr><tr><td>使用 AI 工具的开发者实际完成任务慢了 <strong>19%</strong></td><td>METR 2025 研究</td><td>但他们<em>感觉</em>快了 20%</td></tr></tbody></table><p>最后一条数据特别有意思：开发者觉得自己变快了，但实际上变慢了。这说明 AI 带来的&quot;流畅感&quot;可能是一种错觉。</p><p><strong>这不是说 AI 没用</strong>，而是说：<strong>AI 是工具，不是魔法。需要你来把关。</strong></p><h2 id="_70-问题-ai-能做-70-剩下-30-要你来" tabindex="-1">&quot;70% 问题&quot;：AI 能做 70%，剩下 30% 要你来 <a class="header-anchor" href="#_70-问题-ai-能做-70-剩下-30-要你来" aria-label="Permalink to &quot;&quot;70% 问题&quot;：AI 能做 70%，剩下 30% 要你来&quot;">​</a></h2><p>Google 工程师 Addy Osmani 在 2025 年提出了一个观察：</p><blockquote><p>AI 可以轻松完成一个项目的 70%——生成样板代码、实现标准功能、处理常规逻辑。但剩下的 30% 才是真正的挑战：复杂的业务逻辑、边界情况处理、系统架构决策、性能优化。</p></blockquote><table tabindex="0"><thead><tr><th>AI 擅长的 70%</th><th>需要人类的 30%</th></tr></thead><tbody><tr><td>生成样板代码</td><td>设计系统架构</td></tr><tr><td>实现标准功能</td><td>处理复杂业务逻辑</td></tr><tr><td>写基础的增删改查</td><td>优化性能瓶颈</td></tr><tr><td>套用常见模式</td><td>处理边界情况</td></tr><tr><td>快速出原型</td><td>确保代码安全</td></tr></tbody></table><p>对于基础版学习者来说，好消息是：<strong>你做的项目大部分在&quot;70%&quot;的范围内</strong>。待办清单、个人工具、简单网站——这些正是 AI 最擅长的。</p><h2 id="_80-墙-项目做到-80-后-每一步都变难" tabindex="-1">&quot;80% 墙&quot;：项目做到 80% 后，每一步都变难 <a class="header-anchor" href="#_80-墙-项目做到-80-后-每一步都变难" aria-label="Permalink to &quot;&quot;80% 墙&quot;：项目做到 80% 后，每一步都变难&quot;">​</a></h2><p>另一个常见现象是&quot;80% 墙&quot;：</p><blockquote><p>用 AI 快速做出一个项目的初版很容易，但当你想添加更多功能时，会发现每增加一个功能都比上一个更难。到了大约 80% 的时候，项目会撞上一堵&quot;墙&quot;。</p></blockquote><p><strong>为什么会这样？</strong></p><table tabindex="0"><thead><tr><th>阶段</th><th>AI 的表现</th><th>原因</th></tr></thead><tbody><tr><td>0-50%</td><td>很顺利</td><td>需求简单，代码量少，AI 能完整理解</td></tr><tr><td>50-80%</td><td>开始吃力</td><td>代码变复杂，AI 开始&quot;忘记&quot;之前的上下文</td></tr><tr><td>80%+</td><td>非常困难</td><td>新功能会影响旧功能，AI 难以把握全局</td></tr></tbody></table><p><strong>这不是你的问题</strong>。这是 AI 工具本身的限制——它的&quot;记忆&quot;是有限的，无法像人类一样理解整个项目的来龙去脉。</p><h2 id="vibe-coding-不擅长的五大场景" tabindex="-1">Vibe Coding 不擅长的五大场景 <a class="header-anchor" href="#vibe-coding-不擅长的五大场景" aria-label="Permalink to &quot;Vibe Coding 不擅长的五大场景&quot;">​</a></h2><h3 id="场景一-复杂业务逻辑" tabindex="-1">场景一：复杂业务逻辑 <a class="header-anchor" href="#场景一-复杂业务逻辑" aria-label="Permalink to &quot;场景一：复杂业务逻辑&quot;">​</a></h3><p><strong>为什么困难</strong>：AI 不理解你的业务背景。它能写出&quot;看起来正确&quot;的代码，但逻辑可能是错的。</p><p><strong>真实例子</strong>：</p><ul><li>你让 AI 写一个&quot;会员积分系统&quot;</li><li>AI 生成了代码，看起来能运行</li><li>但它不知道你们公司的积分规则有特殊情况：满 100 积分送 10 积分、生日当天双倍积分、积分有效期 1 年...</li><li>结果：代码能跑，但业务逻辑全错</li></ul><h3 id="场景二-大型项目" tabindex="-1">场景二：大型项目 <a class="header-anchor" href="#场景二-大型项目" aria-label="Permalink to &quot;场景二：大型项目&quot;">​</a></h3><p><strong>为什么困难</strong>：AI 的&quot;上下文窗口&quot;是有限的。当项目有几十个文件、几千行代码时，AI 无法同时&quot;看到&quot;所有内容。</p><table tabindex="0"><thead><tr><th>项目规模</th><th>文件数</th><th>AI 的表现</th></tr></thead><tbody><tr><td>小型（待办清单）</td><td>1-3 个</td><td>很好</td></tr><tr><td>中型（个人博客）</td><td>5-10 个</td><td>还行</td></tr><tr><td>大型（电商网站）</td><td>50+ 个</td><td>力不从心</td></tr></tbody></table><p><strong>会发生什么</strong>：</p><ul><li>代码重复（AI 忘记你已经写过类似功能）</li><li>命名不一致（同一个概念用不同的名字）</li><li>结构混乱（没有统一的组织方式）</li></ul><h3 id="场景三-安全关键功能" tabindex="-1">场景三：安全关键功能 <a class="header-anchor" href="#场景三-安全关键功能" aria-label="Permalink to &quot;场景三：安全关键功能&quot;">​</a></h3><p><strong>为什么困难</strong>：安全漏洞往往藏在细节里，AI 倾向于生成&quot;能用&quot;的代码，而不是&quot;安全&quot;的代码。</p><p>根据 Veracode 2025 报告：</p><ul><li><strong>86%</strong> 的 AI 生成代码未能防御跨站脚本攻击</li><li><strong>88%</strong> 的 AI 生成代码未能防御日志注入攻击</li></ul><p><strong>典型问题</strong>：</p><ul><li>没有验证用户输入</li><li>没有正确处理敏感数据</li><li>使用了有已知漏洞的库</li></ul><p>这就是为什么 5.3 节专门讲安全——<strong>AI 在这方面需要你来把关</strong>。</p><h3 id="场景四-性能优化" tabindex="-1">场景四：性能优化 <a class="header-anchor" href="#场景四-性能优化" aria-label="Permalink to &quot;场景四：性能优化&quot;">​</a></h3><p><strong>为什么困难</strong>：AI 倾向于选择&quot;最简单&quot;的实现方式，而不是&quot;最高效&quot;的。</p><p><strong>真实例子</strong>：</p><ul><li>你让 AI 写一个&quot;搜索功能&quot;</li><li>AI 用最简单的方式实现：遍历所有数据，逐个比较</li><li>数据少的时候没问题</li><li>数据多了（比如 10 万条）就会变得很慢</li></ul><p><strong>会发生什么</strong>：</p><ul><li>小数据量测试时一切正常</li><li>上线后用户变多，系统变慢</li><li>你不知道慢在哪里，因为代码&quot;看起来没问题&quot;</li></ul><h3 id="场景五-调试复杂-bug" tabindex="-1">场景五：调试复杂 bug <a class="header-anchor" href="#场景五-调试复杂-bug" aria-label="Permalink to &quot;场景五：调试复杂 bug&quot;">​</a></h3><p><strong>为什么困难</strong>：AI 只能看到你给它的信息，无法像人类一样&quot;追根溯源&quot;。</p><table tabindex="0"><thead><tr><th>简单 bug</th><th>AI 能帮忙</th></tr></thead><tbody><tr><td>语法错误</td><td>能</td></tr><tr><td>明显的逻辑错误</td><td>能</td></tr><tr><td>报错信息清晰的问题</td><td>能</td></tr></tbody></table><table tabindex="0"><thead><tr><th>复杂 bug</th><th>AI 很难帮</th></tr></thead><tbody><tr><td>间歇性出现的问题</td><td>难</td></tr><tr><td>涉及多个文件的问题</td><td>难</td></tr><tr><td>需要理解业务上下文的问题</td><td>难</td></tr><tr><td>&quot;修了这里，坏了那里&quot;的问题</td><td>难</td></tr></tbody></table><h2 id="一个形象的比喻" tabindex="-1">一个形象的比喻 <a class="header-anchor" href="#一个形象的比喻" aria-label="Permalink to &quot;一个形象的比喻&quot;">​</a></h2><p>Vibe Coding 就像有了翻译软件去国外旅游：</p><table tabindex="0"><thead><tr><th>场景</th><th>翻译软件表现</th><th>Vibe Coding 对应</th></tr></thead><tbody><tr><td>点餐、问路</td><td>完全够用</td><td>做个人工具、简单网站</td></tr><tr><td>日常聊天</td><td>基本够用</td><td>实现标准功能</td></tr><tr><td>深入讨论专业话题</td><td>力不从心</td><td>处理复杂业务逻辑</td></tr><tr><td>谈判、演讲</td><td>几乎不行</td><td>大型项目、高安全要求</td></tr></tbody></table><p>翻译软件能让你的旅行更轻松，但如果你想在那个国家长期生活、工作，还是需要学习语言本身。</p><p>Vibe Coding 也是如此：它能让你快速做出东西，但如果你想做更复杂的项目，可能需要学习更多编程知识。</p><h2 id="本节要点" tabindex="-1">本节要点 <a class="header-anchor" href="#本节要点" aria-label="Permalink to &quot;本节要点&quot;">​</a></h2><ul><li>AI 生成的代码并不完美：45% 有安全隐患，46% 的专业开发者不完全信任</li><li>&quot;70% 问题&quot;：AI 能完成 70%，剩下 30% 需要人类智慧</li><li>&quot;80% 墙&quot;：项目做到 80% 后，每增加一个功能都变难</li><li>五大不擅长场景：复杂业务逻辑、大型项目、安全关键功能、性能优化、复杂 bug 调试</li><li>知道局限性不是坏事——它帮你建立正确预期，在遇到困难时不自我怀疑</li></ul><div class="tip custom-block"><p class="custom-block-title">好消息</p><p>基础版教程涵盖的内容，大部分在 Vibe Coding 的&quot;舒适区&quot;内。你做的待办清单、个人工具、简单网站，正是 AI 最擅长的领域。</p><p>遇到局限性时，不是你不行，是工具有边界。这时候，要么简化需求，要么准备学习更多。</p></div><p>→ <a href="./5.5.3-upgrade-signals.html">5.5.3 什么信号告诉你需要学习更多</a></p>',55)])])}const p=d(i,[["render",e]]);export{q as __pageData,p as default};
