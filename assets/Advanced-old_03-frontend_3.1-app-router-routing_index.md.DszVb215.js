import{_ as t,C as p,c as l,o as s,a3 as o,b as r,w as e,a as c,G as i,a4 as d}from"./chunks/framework.CUcrqFol.js";const R=JSON.parse('{"title":"3.1 你的文件目录就是网站地图——App Router：文件路由与数据获取","description":"3.1 你的文件目录就是网站地图——App Router：文件路由与数据获取 回归 Web 的本质，URL 路径即资源路径。 在这一节，我们要彻底重构你对“路由”的认知。 在传统的 SPA（单页应用）时代，你可能习惯了在一个巨大的 配置文件里写满 的映射关系。那是一种人工维护的映射。 但现在，Next.js App R","frontmatter":{"title":"3.1 你的文件目录就是网站地图——App Router：文件路由与数据获取","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/03-frontend/3.1-app-router-routing/index.md","filePath":"Advanced-old/03-frontend/3.1-app-router-routing/index.md","lastUpdated":1766168364000}'),g={name:"Advanced-old/03-frontend/3.1-app-router-routing/index.md"};function u(h,a,A,b,m,x){const n=p("Mermaid");return s(),l("div",null,[a[1]||(a[1]=o('<h1 id="_3-1-你的文件目录就是网站地图——app-router-文件路由与数据获取" tabindex="-1">3.1 你的文件目录就是网站地图——App Router：文件路由与数据获取 <a class="header-anchor" href="#_3-1-你的文件目录就是网站地图——app-router-文件路由与数据获取" aria-label="Permalink to &quot;3.1 你的文件目录就是网站地图——App Router：文件路由与数据获取&quot;">​</a></h1><blockquote><p>回归 Web 的本质，URL 路径即资源路径。</p></blockquote><p>在这一节，我们要彻底重构你对“路由”的认知。</p><p>在传统的 SPA（单页应用）时代，你可能习惯了在一个巨大的 <code>router.js</code> 配置文件里写满 <code>path: &#39;/about&#39;, component: About</code> 的映射关系。那是一种人工维护的映射。</p><p>但现在，Next.js App Router 带我们回归了 Web 的<strong>第一性原理</strong>：<strong>文件系统的结构，就是 URL 的结构</strong>。你把文件放在哪里，它的网址就是什么。这不仅是工程上的简化，更是“所见即所得”思维的极致体现。</p><h2 id="_1-定义边界-app-router-的物理法则" tabindex="-1">1. 定义边界：App Router 的物理法则 <a class="header-anchor" href="#_1-定义边界-app-router-的物理法则" aria-label="Permalink to &quot;1. 定义边界：App Router 的物理法则&quot;">​</a></h2><p>在开始写代码之前，我们需要先建立一套物理法则。这就像是告诉 AI 建筑师：“在这个世界里，砖块怎么摆放决定了房子的形状。”</p><ul><li><strong>输入 (URL)</strong>：用户在浏览器地址栏输入的路径（如 <code>/dashboard/settings</code>）。</li><li><strong>映射机制</strong>：Next.js 自动寻找 <code>app/dashboard/settings/page.tsx</code>。</li><li><strong>输出 (UI)</strong>：由层层嵌套的 <code>layout.tsx</code> 包裹着最终的 <code>page.tsx</code> 渲染出的 HTML。</li><li><strong>异常边界</strong>：找不到文件？显示 <code>not-found.tsx</code>。报错了？显示 <code>error.tsx</code>。</li></ul><p><strong>一句话心法</strong>：<strong>文件夹是路径，<code>page.tsx</code> 是终点，<code>layout.tsx</code> 是包装纸。</strong></p><h2 id="_2-可视化解构-看不见的路由逻辑" tabindex="-1">2. 可视化解构：看不见的路由逻辑 <a class="header-anchor" href="#_2-可视化解构-看不见的路由逻辑" aria-label="Permalink to &quot;2. 可视化解构：看不见的路由逻辑&quot;">​</a></h2><p>App Router 最难理解的不是“对应关系”，而是“嵌套关系”。当你访问一个深层页面时，Next.js 其实是在像“俄罗斯套娃”一样组装组件。</p>',11)),(s(),r(d,null,{default:e(()=>[i(n,{id:"mermaid-54",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20subgraph%20Browser_URL%20%5B%E6%B5%8F%E8%A7%88%E5%99%A8%20URL%5D%0A%20%20%20%20%20%20%20%20URL1%5B%22%2F%20(%E6%A0%B9%E8%B7%AF%E5%BE%84)%22%5D%0A%20%20%20%20%20%20%20%20URL2%5B%22%2Fblog%22%5D%0A%20%20%20%20%20%20%20%20URL3%5B%22%2Fblog%2Fmy-first-post%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20File_System%20%5B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%5D%0A%20%20%20%20%20%20%20%20RootLayout%5B%22app%2Flayout.tsx%20(%E6%A0%B9%E5%B8%83%E5%B1%80)%22%5D%0A%20%20%20%20%20%20%20%20HomePage%5B%22app%2Fpage.tsx%20(%E9%A6%96%E9%A1%B5)%22%5D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20BlogFolder%5B%22app%2Fblog%2F%22%5D%0A%20%20%20%20%20%20%20%20BlogLayout%5B%22app%2Fblog%2Flayout.tsx%20(%E5%8D%9A%E5%AE%A2%E5%B8%83%E5%B1%80)%22%5D%0A%20%20%20%20%20%20%20%20BlogIndex%5B%22app%2Fblog%2Fpage.tsx%20(%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8)%22%5D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20PostFolder%5B%22app%2Fblog%2F%5Bslug%5D%2F%22%5D%0A%20%20%20%20%20%20%20%20PostPage%5B%22app%2Fblog%2F%5Bslug%5D%2Fpage.tsx%20(%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20URL1%20--%3E%20RootLayout%0A%20%20%20%20RootLayout%20--%3E%20HomePage%0A%20%20%20%20%0A%20%20%20%20URL2%20--%3E%20RootLayout%0A%20%20%20%20RootLayout%20--%3E%20BlogLayout%0A%20%20%20%20BlogLayout%20--%3E%20BlogIndex%0A%20%20%20%20%0A%20%20%20%20URL3%20--%3E%20RootLayout%0A%20%20%20%20RootLayout%20--%3E%20BlogLayout%0A%20%20%20%20BlogLayout%20--%3E%20PostPage%0A%0A%20%20%20%20style%20RootLayout%20fill%3A%23f9f%2Cstroke%3A%23333%2Cstroke-width%3A2px%2Ccolor%3A%23000%0A%20%20%20%20style%20BlogLayout%20fill%3A%23ccf%2Cstroke%3A%23333%2Cstroke-width%3A2px%2Ccolor%3A%23000%0A%20%20%20%20style%20PostPage%20fill%3A%23ff9%2Cstroke%3A%23333%2Cstroke-width%3A2px%2Ccolor%3A%23000%0A"})]),fallback:e(()=>[...a[0]||(a[0]=[c(" Loading... ",-1)])]),_:1})),a[2]||(a[2]=o(`<blockquote><p><strong>觉知点</strong>：注意看图，<code>layout</code> 是<strong>持久化</strong>的。当你从 <code>/blog</code> 跳转到 <code>/blog/my-first-post</code> 时，<code>RootLayout</code> 和 <code>BlogLayout</code> <strong>不会</strong>重新渲染，只有最里面的 <code>page.tsx</code> 变了。这就是 Next.js 极速体验的秘密。</p></blockquote><h2 id="_3-渐进式开发策略-与-ai-结对编程" tabindex="-1">3. 渐进式开发策略：与 AI 结对编程 <a class="header-anchor" href="#_3-渐进式开发策略-与-ai-结对编程" aria-label="Permalink to &quot;3. 渐进式开发策略：与 AI 结对编程&quot;">​</a></h2><p>不要试图一次性写出完美的路由结构。我们要用**MV P（最小可行性产品）**思维，一步步指挥 AI 搭建。</p><h3 id="第一步-搭建骨架-static-routes-layouts" tabindex="-1">第一步：搭建骨架（Static Routes &amp; Layouts） <a class="header-anchor" href="#第一步-搭建骨架-static-routes-layouts" aria-label="Permalink to &quot;第一步：搭建骨架（Static Routes &amp; Layouts）&quot;">​</a></h3><p>先让 AI 帮你搞定最基础的页面结构。</p><blockquote><p><strong>🤖 AI 指令意图</strong>： &quot;帮我创建 App Router 的基础结构。我要一个首页、一个关于页，还有一个共用的导航栏布局。&quot;</p></blockquote><p><strong>关键文件结构：</strong></p><ul><li><code>app/layout.tsx</code>：<strong>必须存在</strong>。这里定义 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</li><li><code>app/page.tsx</code>：首页内容。</li><li><code>app/about/page.tsx</code>：<code>/about</code> 页面内容。</li></ul><p><strong>验收清单：</strong></p><ul><li>[ ] 访问 <code>http://localhost:3000/</code> 能看到首页？</li><li>[ ] 访问 <code>http://localhost:3000/about</code> 能看到关于页？</li><li>[ ] 两个页面是否都有相同的导航栏（来自 <code>layout.tsx</code>）？</li></ul><h3 id="第二步-处理动态内容-dynamic-routes" tabindex="-1">第二步：处理动态内容（Dynamic Routes） <a class="header-anchor" href="#第二步-处理动态内容-dynamic-routes" aria-label="Permalink to &quot;第二步：处理动态内容（Dynamic Routes）&quot;">​</a></h3><p>现在，我们要处理“成千上万”个页面了，比如博客文章或用户资料。我们不能手动创建 <code>post-1.tsx</code>, <code>post-2.tsx</code>。</p><blockquote><p><strong>AI 指令意图</strong>： &quot;我要做一个博客详情页。请在 <code>app/blog</code> 下创建一个动态路由，用 <code>slug</code> 作为参数。并在页面中把这个 <code>slug</code> 参数打印出来。&quot;</p></blockquote><p><strong>关键代码逻辑 (<code>app/blog/[slug]/page.tsx</code>)：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 这里的 params 是 Next.js 自动传入的</span></span>
<span class="line"><span>// 注意：params 在 Next.js 16+ 中可能是异步的，具体视版本而定，但在 Vibe Coding 体系中我们通常直接解构</span></span>
<span class="line"><span>export default async function BlogPost({ params }: { params: { slug: string } }) {</span></span>
<span class="line"><span>  // 1. 获取 URL 上的参数</span></span>
<span class="line"><span>  const { slug } = params; </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  return &lt;div&gt;正在阅读文章：{slug}&lt;/div&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="第三步-组织与整理-route-groups" tabindex="-1">第三步：组织与整理（Route Groups） <a class="header-anchor" href="#第三步-组织与整理-route-groups" aria-label="Permalink to &quot;第三步：组织与整理（Route Groups）&quot;">​</a></h3><p>如果你的项目变大了，<code>app</code> 文件夹下一堆文件夹乱糟糟的怎么办？比如你想区分“管理后台”和“营销页面”，但不想让 URL 变成 <code>/marketing/home</code>。</p><p>这时候就需要 <strong>Route Groups（路由组）</strong>。这是一种**“只有文件夹，没有 URL”**的魔法。</p><blockquote><p><strong>🤖 AI 指令意图</strong>： &quot;我想把代码组织得更清晰。请把营销相关的页面（首页、关于）放在 <code>(marketing)</code> 组里，把后台页面放在 <code>(dashboard)</code> 组里。确保 URL 路径<strong>不包含</strong>括号里的名字。&quot;</p></blockquote><p><strong>效果：</strong></p><ul><li><code>app/(marketing)/about/page.tsx</code> -&gt; URL 依然是 <code>/about</code></li><li><code>app/(dashboard)/settings/page.tsx</code> -&gt; URL 依然是 <code>/settings</code></li></ul><h2 id="_4-数据获取-server-component-的-特权" tabindex="-1">4. 数据获取：Server Component 的“特权” <a class="header-anchor" href="#_4-数据获取-server-component-的-特权" aria-label="Permalink to &quot;4. 数据获取：Server Component 的“特权”&quot;">​</a></h2><p>这是 Vibe Coding 技术栈最迷人的地方。忘记 <code>useEffect</code>，忘记 <code>isLoading</code> 状态管理。在 App Router 里，我们在<strong>服务器</strong>上直接拿数据。</p><h3 id="核心概念-fetch-cache-revalidate" tabindex="-1">核心概念：Fetch, Cache, Revalidate <a class="header-anchor" href="#核心概念-fetch-cache-revalidate" aria-label="Permalink to &quot;核心概念：Fetch, Cache, Revalidate&quot;">​</a></h3><p>在 <code>page.tsx</code> (Server Component) 中，获取数据就像写普通的 Node.js 脚本一样简单。</p><blockquote><p><strong>🤖 AI 协作指南</strong>： 告诉 AI：“我要在这个页面获取博客列表数据。请使用 <code>fetch</code> API，并配置数据缓存策略。”</p></blockquote><p><strong>实战代码模板：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// app/blog/page.tsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 1. 定义数据获取函数</span></span>
<span class="line"><span>async function getPosts() {</span></span>
<span class="line"><span>  // Next.js 扩展了原生的 fetch</span></span>
<span class="line"><span>  const res = await fetch(&#39;[https://api.example.com/posts](https://api.example.com/posts)&#39;, {</span></span>
<span class="line"><span>    // 策略 A: 静态生成 (默认) - 像 SSG，构建时获取，永久缓存</span></span>
<span class="line"><span>    // cache: &#39;force-cache&#39;, </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 策略 B: 动态渲染 - 像 SSR，每次请求都重新获取</span></span>
<span class="line"><span>    // cache: &#39;no-store&#39;,</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 策略 C: 增量静态再生 (ISR) - Vibe Coding 推荐！</span></span>
<span class="line"><span>    // 每 3600 秒更新一次缓存，兼顾速度与新鲜度</span></span>
<span class="line"><span>    next: { revalidate: 3600 }</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (!res.ok) throw new Error(&#39;Failed to fetch posts&#39;);</span></span>
<span class="line"><span>  return res.json();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 2. 页面组件直接变成 async</span></span>
<span class="line"><span>export default async function BlogPage() {</span></span>
<span class="line"><span>  // 3. 直接 await 数据，就像在后端写代码一样</span></span>
<span class="line"><span>  const posts = await getPosts();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;ul&gt;</span></span>
<span class="line"><span>      {posts.map((post: any) =&gt; (</span></span>
<span class="line"><span>        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;</span></span>
<span class="line"><span>      ))}</span></span>
<span class="line"><span>    &lt;/ul&gt;</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="为什么这很-vibe" tabindex="-1">为什么这很“Vibe”？ <a class="header-anchor" href="#为什么这很-vibe" aria-label="Permalink to &quot;为什么这很“Vibe”？&quot;">​</a></h3><ol><li><strong>没有白屏加载</strong>：数据在服务器拿好后，带着 HTML 一起发给浏览器。</li><li><strong>零客户端 JS</strong>：获取数据的逻辑不会打包到客户端，减小体积。</li><li><strong>直觉</strong>：需要数据？那就去拿。不需要复杂的状态管理库。</li></ol><h2 id="_5-验收清单-checklist" tabindex="-1">5. 验收清单 (Checklist) <a class="header-anchor" href="#_5-验收清单-checklist" aria-label="Permalink to &quot;5. 验收清单 (Checklist)&quot;">​</a></h2><p>在这一章结束时，请按照以下标准验收你的成果：</p><ol><li>[ ] <strong>文件结构清晰</strong>：我能通过看文件目录，就能画出网站的 Sitemap。</li><li>[ ] <strong>路由跳转流畅</strong>：使用 <code>&lt;Link&gt;</code> 组件在页面间跳转，且 Layout 没有不必要的闪烁。</li><li>[ ] <strong>Loading 状态</strong>：在数据加载慢的页面旁边放一个 <code>loading.tsx</code>，验证是否能自动显示骨架屏。</li><li>[ ] <strong>数据获取正确</strong>：修改数据库或 API 数据后，页面的更新行为符合你设置的 <code>revalidate</code> 时间（试试设置为 0 或 10 秒来测试）。</li></ol><h2 id="_6-下一步" tabindex="-1">6. 下一步 <a class="header-anchor" href="#_6-下一步" aria-label="Permalink to &quot;6. 下一步&quot;">​</a></h2><p>现在你的页面已经跑起来了，数据也有了。但是它们长得还很丑，而且是一堆散乱的积木。下一节，我们将学习<strong>3.2 像搭乐高一样构建页面</strong>，用组件化思维把这些页面变得漂亮且可复用。</p>`,35))])}const f=t(g,[["render",u]]);export{R as __pageData,f as default};
