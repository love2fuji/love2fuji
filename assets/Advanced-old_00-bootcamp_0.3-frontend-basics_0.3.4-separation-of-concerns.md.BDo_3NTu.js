import{_ as l,C as i,c as s,o as e,a3 as t,b as n,w as a,a as c,G as d,a4 as p}from"./chunks/framework.CUcrqFol.js";const m=JSON.parse('{"title":"0.3.4 为什么骨架、衣服和动作要分开——三者协作：分离关注点的设计思想","description":"0.3.4 为什么骨架、衣服和动作要分开——三者协作：分离关注点的设计思想 认知重构：从“大杂烩”到“各司其职” 初学者最容易犯的错误，就是把 HTML, CSS, 和 JavaScript 搅和在一起，写出“大杂烩”式的代码。比如，在 HTML 标签里直接写 属性，或者用 属性执行 JavaScript 代码。 这种","frontmatter":{"title":"0.3.4 为什么骨架、衣服和动作要分开——三者协作：分离关注点的设计思想","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/00-bootcamp/0.3-frontend-basics/0.3.4-separation-of-concerns.md","filePath":"Advanced-old/00-bootcamp/0.3-frontend-basics/0.3.4-separation-of-concerns.md","lastUpdated":1766168364000}'),E={name:"Advanced-old/00-bootcamp/0.3-frontend-basics/0.3.4-separation-of-concerns.md"};function S(A,o,u,B,g,h){const r=i("Mermaid");return e(),s("div",null,[o[1]||(o[1]=t('<h1 id="_0-3-4-为什么骨架、衣服和动作要分开——三者协作-分离关注点的设计思想" tabindex="-1">0.3.4 为什么骨架、衣服和动作要分开——三者协作：分离关注点的设计思想 <a class="header-anchor" href="#_0-3-4-为什么骨架、衣服和动作要分开——三者协作-分离关注点的设计思想" aria-label="Permalink to &quot;0.3.4 为什么骨架、衣服和动作要分开——三者协作：分离关注点的设计思想&quot;">​</a></h1><h2 id="认知重构-从-大杂烩-到-各司其职" tabindex="-1">认知重构：从“大杂烩”到“各司其职” <a class="header-anchor" href="#认知重构-从-大杂烩-到-各司其职" aria-label="Permalink to &quot;认知重构：从“大杂烩”到“各司其职”&quot;">​</a></h2><p>初学者最容易犯的错误，就是把 HTML, CSS, 和 JavaScript 搅和在一起，写出“大杂烩”式的代码。比如，在 HTML 标签里直接写 <code>style</code> 属性，或者用 <code>onclick</code> 属性执行 JavaScript 代码。</p><p>这种做法在小规模的练习中看似方便，但在真实项目中，它是一场灾难的开始。代码会变得极难阅读、维护和扩展。想象一下，要修改一个按钮的颜色，你可能需要在几十个 HTML 文件中手动搜索和替换，而不是只改动一个 CSS 文件的一行代码。</p><p><strong>正确的认知：HTML, CSS, 和 JavaScript 是一个团队，但团队成员应该各司其职，而不是互相干涉。</strong> 这种思想，就是软件工程中至关重要的<strong>关注点分离 (Separation of Concerns, SoC)</strong>。</p><ul><li><strong>HTML (结构层)</strong>: 只负责定义页面的内容和结构。它像建筑的钢筋骨架，决定了哪里是客厅，哪里是卧室。</li><li><strong>CSS (表现层)</strong>: 只负责定义页面的样式和布局。它像建筑的室内设计，决定了墙壁刷什么颜色的漆，家具如何摆放。</li><li><strong>JavaScript (行为层)</strong>: 只负责定义页面的交互和逻辑。它像建筑的水电系统，让灯能亮，水能流。</li></ul><h2 id="本质还原-一种可持续维护的契约" tabindex="-1">本质还原：一种可持续维护的契约 <a class="header-anchor" href="#本质还原-一种可持续维护的契约" aria-label="Permalink to &quot;本质还原：一种可持续维护的契约&quot;">​</a></h2><p>关注点分离的本质，是在这三层之间建立一种清晰的、可持续维护的“契约”。</p><ul><li><strong>CSS 通过“选择器”与 HTML 签订契约</strong>。CSS 说：“我不管你 HTML 结构怎么变，只要你有一个 class 是 <code>primary-button</code> 的元素，我就会把它渲染成蓝色。”</li><li><strong>JavaScript 通过“选择器”和“事件”与 HTML 签订契约</strong>。JavaScript 说：“我不管你长什么样，只要页面里有一个 ID 是 <code>login-form</code> 的表单，并且它被提交 (submit) 了，我就会负责处理登录逻辑。”</li></ul><p>这种基于“契约”的协作模式，使得三层可以独立地进行修改和扩展，而不会轻易地破坏彼此的功能。</p><h2 id="可视化解构-三层协作模型" tabindex="-1">可视化解构：三层协作模型 <a class="header-anchor" href="#可视化解构-三层协作模型" aria-label="Permalink to &quot;可视化解构：三层协作模型&quot;">​</a></h2>',11)),(e(),n(p,null,{default:a(()=>[d(r,{id:"mermaid-56",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20subgraph%20sg1%20%5B%22%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%22%5D%0A%20%20%20%20%20%20%20%20direction%20LR%0A%20%20%20%20%20%20%20%20HTML%5B%22HTML%20(%E7%BB%93%E6%9E%84)%22%5D%20--%20%22%E5%AE%9A%E4%B9%89%E4%BA%86%E9%AA%A8%E6%9E%B6%22%20--%3E%20BrowserRender%5B%22%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%22%5D%3B%0A%20%20%20%20%20%20%20%20CSS%5B%22CSS%20(%E6%A0%B7%E5%BC%8F)%22%5D%20--%20%22%E6%8F%90%E4%BE%9B%E6%A0%B7%E5%BC%8F%E8%A7%84%E5%88%99%22%20--%3E%20BrowserRender%3B%0A%20%20%20%20%20%20%20%20JS%5B%22JavaScript%20(%E8%A1%8C%E4%B8%BA)%22%5D%20--%20%22%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%2F%E6%93%8D%E4%BD%9CDOM%22%20--%3E%20BrowserRender%3B%0A%20%20%20%20%20%20%20%20BrowserRender%20--%20%22%E6%9E%84%E5%BB%BA%E6%9C%80%E7%BB%88%E9%A1%B5%E9%9D%A2%22%20--%3E%20UserView%5B%E7%94%A8%E6%88%B7%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A1%B5%E9%9D%A2%5D%3B%0A%20%20%20%20%20%20%20%20UserView%20--%20%22%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92(%E7%82%B9%E5%87%BB%2F%E8%BE%93%E5%85%A5)%22%20--%3E%20JS%3B%0A%20%20%20%20end%0A%0A%20%20%20%20style%20HTML%20fill%3A%23f2f2f2%2Cstroke%3A%23333%0A%20%20%20%20style%20CSS%20fill%3A%23e6f7ff%2Cstroke%3A%23333%0A%20%20%20%20style%20JS%20fill%3A%23fffbe6%2Cstroke%3A%23333%0A"})]),fallback:a(()=>[...o[0]||(o[0]=[c(" Loading... ",-1)])]),_:1})),o[2]||(o[2]=t('<p>这张图清晰地展示了：</p><ol><li>HTML, CSS, JS 作为独立的模块被浏览器加载。</li><li>浏览器渲染引擎将它们“组合”起来，生成用户最终看到的页面。</li><li>用户的交互行为（如点击）会触发 JavaScript，JavaScript 再去操作 DOM（即改变 HTML 结构或通过修改 class 来间接改变 CSS），从而更新视图，形成一个完整的交互闭环。</li></ol><h2 id="觉知-如何识破-坏代码" tabindex="-1">觉知：如何识破“坏代码” <a class="header-anchor" href="#觉知-如何识破-坏代码" aria-label="Permalink to &quot;觉知：如何识破“坏代码”&quot;">​</a></h2><p>当你 Review AI 生成的代码时，要像一个经验丰富的架构师一样，对违反“关注点分离”原则的“坏味道”保持警惕：</p><ul><li><p><strong>HTML 中的 <code>style</code> 属性</strong>: <code>&lt;p style=&quot;color: red; font-size: 14px;&quot;&gt;...&lt;/p&gt;</code></p><ul><li><strong>为什么是坏味道？</strong> 这将样式死死地焊在了结构上。如果未来需要统一修改所有段落的字体大小，这将是一场噩梦。</li><li><strong>正确做法</strong>: 在 CSS 文件中定义一个类 <code>.error-text { color: red; font-size: 14px; }</code>，然后在 HTML 中使用 <code>&lt;p class=&quot;error-text&quot;&gt;...&lt;/p&gt;</code>。</li></ul></li><li><p><strong>HTML 中的 <code>on*</code> 事件属性</strong>: <code>&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;</code></p><ul><li><strong>为什么是坏味道？</strong> 这将行为与结构混合。使得 JavaScript 代码散落在各个 HTML 文件中，难以管理和调试。</li><li><strong>正确做法</strong>: 在独立的 JS 文件中，通过 <code>document.getElementById(&#39;my-button&#39;).addEventListener(&#39;click&#39;, myFunction);</code> 来绑定事件。</li></ul></li><li><p><strong>JavaScript 中直接操作 <code>style</code></strong>: <code>element.style.color = &#39;blue&#39;; element.style.backgroundColor = &#39;white&#39;;</code></p><ul><li><strong>为什么是坏味道？</strong> 当需要修改的样式很多时，这会让 JS 代码变得臃肿且混乱，把表现层的逻辑带入了行为层。</li><li><strong>正确做法</strong>: 在 CSS 中预先定义一个类 <code>.is-active { color: blue; background-color: white; }</code>，然后在 JS 中只做一件事：<code>element.classList.add(&#39;is-active&#39;);</code>。让 JS 专注于“切换状态”，而不是关心“状态的具体样式”。</li></ul></li></ul><h2 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h2><h3 id="核心意图" tabindex="-1">核心意图 <a class="header-anchor" href="#核心意图" aria-label="Permalink to &quot;核心意图&quot;">​</a></h3><p>向 AI 强调你希望它生成**“结构、样式、行为分离”**的代码。</p><h3 id="需求定义公式" tabindex="-1">需求定义公式 <a class="header-anchor" href="#需求定义公式" aria-label="Permalink to &quot;需求定义公式&quot;">​</a></h3><p><strong>“给我创建一个[组件]，请将 HTML, CSS, 和 JavaScript 分别放在独立的代码块中。使用 class 作为 CSS 和 JavaScript 的连接点。”</strong></p><ul><li><strong>示例</strong>：“我需要一个可折叠的手风琴组件。请为我提供三部分代码：HTML 结构（使用 <code>div</code> 和 <code>button</code>），CSS 样式（定义展开和折叠两种状态的 class），以及 JavaScript 逻辑（通过切换 class 来控制展开和折叠，而不是直接操作 style）。”</li></ul><h3 id="交互策略" tabindex="-1">交互策略 <a class="header-anchor" href="#交互策略" aria-label="Permalink to &quot;交互策略&quot;">​</a></h3><ol><li><strong>强制分离</strong>：明确要求 AI “不要使用内联样式 (inline style)” 和 “不要使用 on-event 属性”。</li><li><strong>基于状态切换进行沟通</strong>：多使用“切换 class”、“添加/移除 class”这样的指令，引导 AI 通过改变状态（class）来驱动视图变化。</li><li><strong>分步索取</strong>：你可以先让 AI 生成 HTML 结构，然后基于这个结构，再让它分别生成 CSS 和 JavaScript。这能让你更好地控制每一部分代码的质量。</li></ol><p>掌握了“关注点分离”，你就掌握了编写可维护、可扩展前端代码的钥匙。这是从入门到专业的必经之路，也是与 AI 高效协作，产出高质量代码的基础。</p>',14))])}const C=l(E,[["render",S]]);export{m as __pageData,C as default};
