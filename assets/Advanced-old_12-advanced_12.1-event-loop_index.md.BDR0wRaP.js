import{_ as r,C as l,c as n,o as a,a3 as o,b as s,w as t,a as d,G as c,a4 as u}from"./chunks/framework.CUcrqFol.js";const E=JSON.parse('{"title":"12.1 为什么 JS 能一心多用——Node 进程与事件循环：回调/Promise/async-await","description":"12.1 为什么 JS 能一心多用——Node 进程与事件循环：回调/Promise/async-await 一句话破题 JavaScript 是**单线程**语言，却能同时处理网络请求、文件读写、用户交互——这一切的秘密，都藏在**事件循环**这个\\"任务调度员\\"身上。 核心价值 理解事件循环，是从\\"会写异步代码\\"到\\"","frontmatter":{"title":"12.1 为什么 JS 能一心多用——Node 进程与事件循环：回调/Promise/async-await","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/12-advanced/12.1-event-loop/index.md","filePath":"Advanced-old/12-advanced/12.1-event-loop/index.md","lastUpdated":1766168364000}'),p={name:"Advanced-old/12-advanced/12.1-event-loop/index.md"};function m(_,e,A,q,h,B){const i=l("Mermaid");return a(),n("div",null,[e[1]||(e[1]=o('<h1 id="_12-1-为什么-js-能一心多用——node-进程与事件循环-回调-promise-async-await" tabindex="-1">12.1 为什么 JS 能一心多用——Node 进程与事件循环：回调/Promise/async-await <a class="header-anchor" href="#_12-1-为什么-js-能一心多用——node-进程与事件循环-回调-promise-async-await" aria-label="Permalink to &quot;12.1 为什么 JS 能一心多用——Node 进程与事件循环：回调/Promise/async-await&quot;">​</a></h1><h3 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h3><p>JavaScript 是<strong>单线程</strong>语言，却能同时处理网络请求、文件读写、用户交互——这一切的秘密，都藏在<strong>事件循环</strong>这个&quot;任务调度员&quot;身上。</p><h3 id="核心价值" tabindex="-1">核心价值 <a class="header-anchor" href="#核心价值" aria-label="Permalink to &quot;核心价值&quot;">​</a></h3><p>理解事件循环，是从&quot;会写异步代码&quot;到&quot;能调试异步 Bug&quot;的分水岭。当你遇到以下问题时，事件循环就是你的诊断工具：</p><ul><li>为什么 <code>setTimeout(fn, 0)</code> 不会立即执行？</li><li>为什么 <code>Promise.then</code> 比 <code>setTimeout</code> 先执行？</li><li>为什么页面会&quot;卡死&quot;？</li><li>为什么数据库查询后拿到的是 <code>undefined</code>？</li></ul><h3 id="本章导览" tabindex="-1">本章导览 <a class="header-anchor" href="#本章导览" aria-label="Permalink to &quot;本章导览&quot;">​</a></h3><p>本节将从底层机制出发，带你理解 JavaScript 异步编程的演进之路：</p>',8)),(a(),s(u,null,{default:t(()=>[c(i,{id:"mermaid-43",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20A%5B%22%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%22%5D%20--%3E%20B%5B%22%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%22%5D%3B%0A%20%20%20%20B%20--%3E%20C%5B%22Promise%22%5D%3B%0A%20%20%20%20C%20--%3E%20D%5B%22async%2Fawait%22%5D%3B%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%23f9f%2Cstroke%3A%23333%0A%20%20%20%20style%20D%20fill%3A%239f9%2Cstroke%3A%23333%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[d(" Loading... ",-1)])]),_:1})),e[2]||(e[2]=o('<ol><li><strong>事件循环机制</strong>：理解 Call Stack、Event Queue、微任务与宏任务的调度规则。</li><li><strong>回调函数</strong>：异步编程的起点，以及它带来的&quot;回调地狱&quot;问题。</li><li><strong>Promise</strong>：用链式调用解决嵌套问题，并引入统一的错误处理。</li><li><strong>async/await</strong>：让异步代码&quot;看起来像同步&quot;，提升可读性和可维护性。</li></ol><h3 id="为什么-vibe-coder-必须懂这些" tabindex="-1">为什么 Vibe Coder 必须懂这些？ <a class="header-anchor" href="#为什么-vibe-coder-必须懂这些" aria-label="Permalink to &quot;为什么 Vibe Coder 必须懂这些？&quot;">​</a></h3><p>在 AI 辅助编程的时代，你可以让 AI 帮你写异步代码。但当代码出问题时，AI 给出的解释往往是&quot;照本宣科&quot;的。<strong>只有你真正理解事件循环，才能在 AI 的建议中识别出正确的方向，而非盲目接受一个&quot;看起来合理&quot;的答案。</strong></p><blockquote><p>面对 AI 生成的异步代码，你的核心审查点是：</p><ul><li>这段代码的执行顺序是否符合预期？</li><li>是否存在竞态条件？</li><li>错误是否被正确捕获？</li></ul></blockquote>',4))])}const b=r(p,[["render",m]]);export{E as __pageData,b as default};
