import{_ as r,c as t,o as n,a3 as e}from"./chunks/framework.CUcrqFol.js";const P=JSON.parse('{"title":"第三章：PRD与文档驱动开发","description":"第三章：PRD与文档驱动开发 序言 在让 AI 写代码之前，老师傅按住了你想要狂飙的手。他告诉你，**写代码之前，先写文档**。如果没有蓝图，AI 很容易就会像脱缰的野马，生成的代码往往缺乏结构，写出一堆谁也看不懂、改不动的功能。 你开始学习编写 **PRD（产品需求文档）**。老师傅直接甩给你一份成熟的模板，并拍板决","frontmatter":{"title":"第三章：PRD与文档驱动开发"},"headers":[],"relativePath":"Advanced/03-prd-doc-driven/index.md","filePath":"Advanced/03-prd-doc-driven/index.md","lastUpdated":1766339035000}'),s={name:"Advanced/03-prd-doc-driven/index.md"};function d(g,o,a,c,i,p){return n(),t("div",null,[...o[0]||(o[0]=[e('<h1 id="第三章-prd与文档驱动开发" tabindex="-1">第三章：PRD与文档驱动开发 <a class="header-anchor" href="#第三章-prd与文档驱动开发" aria-label="Permalink to &quot;第三章：PRD与文档驱动开发&quot;">​</a></h1><h2 id="序言" tabindex="-1">序言 <a class="header-anchor" href="#序言" aria-label="Permalink to &quot;序言&quot;">​</a></h2><p>在让 AI 写代码之前，老师傅按住了你想要狂飙的手。他告诉你，<strong>写代码之前，先写文档</strong>。如果没有蓝图，AI 很容易就会像脱缰的野马，生成的代码往往缺乏结构，写出一堆谁也看不懂、改不动的功能。</p><p>你开始学习编写 <strong>PRD（产品需求文档）</strong>。老师傅直接甩给你一份成熟的模板，并拍板决定了 <strong>Next.js 16 全栈</strong>（搭配 <strong>Prisma</strong> 和 <strong>PostgreSQL</strong>）的技术栈。看着你对 <strong>Prisma</strong> 和 <strong>PostgreSQL</strong> 这两个数据库名词一头雾水的样子，老师傅摆摆手打断了你的提问：“<strong>关于数据怎么存，后面会有专门的章节详细讲，现在别深究。</strong>” 他只是顺带提了一嘴，Prisma 的 <code>schema</code> 文件本身就是一份绝佳的数据库结构文档，非常适合在现阶段用来理清数据之间的关系。除了梳理业务逻辑，你意识到还需要记录具体的技术实现方案，也就是技术文档。老师傅点点头，表示对于现在的你来说，不必拘泥于形式，完全可以将技术文档与PRD合并，统称为项目文档，这样查阅起来更方便。</p><p>在编写文档的过程中，你还顺便了解了 <strong>Markdown (.md)</strong> 和 <strong>Mermaid</strong>。Markdown 用于编写排版整齐的文本，Mermaid 用于通过文字代码绘制流程图、时序图。老师傅说，将这些文档提供给 AI，它生成的代码准确率显著提升。在这个过程中，你还顺便搞懂了 <strong>JSON</strong> 和 <strong>YAML</strong> 这种奇怪的配置文件格式。原来，对于 AI 来说，相比于散漫的自然语言，这些结构清晰的格式才是它们最爱读的“说明书”。<strong>经过老师傅的教导，你进一步理解了前后端交互、API 是什么，HTTP 是什么——本质上就是两个程序通过 HTTP 协议互相发送 JSON 数据包的过程。</strong></p><p>在规划功能时，你遇到了两个必须提前考虑的问题：</p><p><strong>鉴权与模块拆分</strong> 你想要做用户系统，这涉及到鉴权。你想要做地图功能，这涉及到“外部 API”。老师傅提醒你，不要把所有代码都塞在一个文件里，要学会把功能拆分成不同的模块，比如 <code>auth</code>（认证）、<code>api</code>（接口）、<code>components</code>（组件）。这种<strong>模块化思维</strong>是项目能长期维护的关键。</p><p><strong>API 文档与集成</strong> 你想接入 AI 能力，或者地图服务等。老师傅告诉你，这些外部 API 通常是收费的，但对开发者很友好，一般都有免费额度供你测试。你需要做的是：</p><ol><li><strong>获取凭证</strong>：找到官方开放平台的开发者文档，找到你需要的功能，注册账号生成 <strong>API Key</strong>（这是你的敏感凭证，切勿泄露）。老师傅特意叮嘱，<strong>一定要把 Key 保存到环境变量 <code>.env</code> 文件中</strong>，而不是直接写死在代码里。环境变量就像是代码和密钥之间的“防火墙”，只要让 AI 配置一下，程序运行时会自动去读取它们，这样既能保证功能正常，又能防止你把密钥上传到 GitHub 被人盗用。</li><li><strong>确立技术路线（SDK vs HTTP）</strong>：老师傅阻止了你让 AI 手写原始 HTTP 请求的想法。他介绍了 <strong>SDK（软件开发工具包）</strong> 的概念——官方通常已经把复杂的网络交互、错误处理和验证逻辑封装好了，只需要安装一下就可以直接使用。<strong>更关键的是，官方 SDK 通常自带完善的 TypeScript 类型定义</strong>。这相当于给 AI 提供了代码指南，它能准确地知道有哪些功能可用，参数该怎么填，这比让它对着空白的 HTTP 请求瞎编要靠谱得多。特别是 <strong>Vercel AI SDK</strong>，它极大地简化了 AI 应用的开发。它帮你处理了技术难度较高的“流式传输”协议，让 AI 的回复能够实时逐字显示。如果你非要手写 Fetch 请求，不仅代码量翻倍，还很难实现这种流畅的交互体验。</li><li><strong>归档参考文档</strong>：将这些 API 的关键文档（如请求格式、示例代码、返回码）整理好，归档在项目中（比如 <code>docs/api-reference.md</code>）。这样下次你需要 AI 写相关功能时，直接把这份文档喂给它，它就能精准地写出调用代码，而不是编造一个不存在的接口。</li></ol><p><strong>项目说明书 (README.md)</strong> 你终于意识到，代码不仅是给机器运行的，也是给人和 AI 阅读的。你还学会了写 <strong>README.md</strong>。这不是冗余信息，而是项目的“说明书”。你在里面清晰地记录了如何启动项目（<code>pnpm dev</code>）、如何配置环境变量、核心功能的逻辑。从此，无论是谁，直接看文档就上手了。</p><p>最后，老师傅还顺带提到了 <strong>Swagger</strong>。他让你记住这个工具，以后当项目变得复杂，利用 Swagger 自动生成接口文档，能更高效地确保文档与代码实现保持一致。</p><p>对了，记得让 AI 随时保持文档的更新。</p>',12)])])}const l=r(s,[["render",d]]);export{P as __pageData,l as default};
