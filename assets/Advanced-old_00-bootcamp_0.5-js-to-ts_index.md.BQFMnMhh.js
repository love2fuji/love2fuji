import{_ as l,C as d,c as n,o as a,a3 as o,b as r,w as t,a as c,G as s,a4 as u}from"./chunks/framework.CUcrqFol.js";const b=JSON.parse('{"title":"0.5 从随心所欲到规行矩步——JS → TS 思维转换","description":"0.5 从随心所欲到规行矩步——JS → TS 思维转换 一句话破题 TypeScript 的价值不在“语法更复杂”，而在于把“运行时报错”提前到“编译期”。它让协作像签合同一样明确，减少猜测与隐性 bug。 章节导览 动态与静态的核心差异：数据先有类型，再写逻辑。 基础类型与复合类型：从 到 。 接口与类型别名： v","frontmatter":{"title":"0.5 从随心所欲到规行矩步——JS → TS 思维转换","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/00-bootcamp/0.5-js-to-ts/index.md","filePath":"Advanced-old/00-bootcamp/0.5-js-to-ts/index.md","lastUpdated":1766168364000}'),E={name:"Advanced-old/00-bootcamp/0.5-js-to-ts/index.md"};function _(h,e,p,m,B,A){const i=d("Mermaid");return a(),n("div",null,[e[1]||(e[1]=o('<h1 id="_0-5-从随心所欲到规行矩步——js-→-ts-思维转换" tabindex="-1">0.5 从随心所欲到规行矩步——JS → TS 思维转换 <a class="header-anchor" href="#_0-5-从随心所欲到规行矩步——js-→-ts-思维转换" aria-label="Permalink to &quot;0.5 从随心所欲到规行矩步——JS → TS 思维转换&quot;">​</a></h1><h2 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h2><p>TypeScript 的价值不在“语法更复杂”，而在于把“运行时报错”提前到“编译期”。它让协作像签合同一样明确，减少猜测与隐性 bug。</p><h2 id="章节导览" tabindex="-1">章节导览 <a class="header-anchor" href="#章节导览" aria-label="Permalink to &quot;章节导览&quot;">​</a></h2><ul><li>动态与静态的核心差异：数据先有类型，再写逻辑。</li><li>基础类型与复合类型：从 <code>string/number/boolean</code> 到 <code>array/object</code>。</li><li>接口与类型别名：<code>interface</code> vs <code>type</code> 的适用场景。</li><li>联合与交叉：<code>|</code> 与 <code>&amp;</code> 的建模方式。</li><li>类型缩小：类型守卫与断言的工程用法。</li><li>unknown vs any：安全边界与折中方案。</li><li>严格模式与团队规范：<code>strict/noImplicitAny/noImplicitReturns</code> 等。</li></ul><h2 id="可视化总览" tabindex="-1">可视化总览 <a class="header-anchor" href="#可视化总览" aria-label="Permalink to &quot;可视化总览&quot;">​</a></h2>',6)),(a(),r(u,null,{default:t(()=>[s(i,{id:"mermaid-52",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20JS%5B%22%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B(JS)%22%5D%20--%3E%20Risk%5B%22%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%A3%8E%E9%99%A9%22%5D%3B%0A%20%20%20%20TS%5B%22%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B(TS)%22%5D%20--%3E%20Check%5B%22%E7%BC%96%E8%AF%91%E6%9C%9F%E6%A3%80%E6%9F%A5%22%5D%3B%0A%20%20%20%20Check%20--%3E%20Safety%5B%22%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%2F%E5%8D%8F%E4%BD%9C%E6%B8%85%E6%99%B0%22%5D%3B%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[c(" Loading... ",-1)])]),_:1})),e[2]||(e[2]=o('<h2 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h2><ul><li>核心意图：让 AI 按“契约”生成类型与函数签名，再填充实现。</li><li>需求定义公式： <ul><li>“给我为用户列表写一个类型定义与分页函数的签名，要求返回值包含分页信息与总数。”</li></ul></li><li>关键术语：<code>interface</code>, <code>type</code>, <code>union</code>, <code>intersection</code>, <code>narrowing</code>, <code>unknown</code>。</li></ul><h2 id="避坑指南" tabindex="-1">避坑指南 <a class="header-anchor" href="#避坑指南" aria-label="Permalink to &quot;避坑指南&quot;">​</a></h2><ul><li>禁止使用 <code>any</code>；不确定类型时用 <code>unknown</code> 并收窄。</li><li>断言不是“消灭错误”的工具；先做类型守卫再断言。</li><li>别在实现中偷换返回类型；函数签名就是契约。</li></ul>',4))])}const T=l(E,[["render",_]]);export{b as __pageData,T as default};
