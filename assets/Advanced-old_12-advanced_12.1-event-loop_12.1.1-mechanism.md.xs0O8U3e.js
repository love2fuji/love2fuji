import{_ as k,C as p,c as r,o as i,a3 as t,b as l,w as a,a as e,G as h,a4 as E}from"./chunks/framework.CUcrqFol.js";const y=JSON.parse('{"title":"12.1.1 JS 的心脏——事件循环机制：Call Stack/Event Queue/Callback Queue","description":"12.1.1 JS 的心脏——事件循环机制：Call Stack/Event Queue/Callback Queue 一句话破题 事件循环是 JavaScript 引擎的\\"心脏\\"，它不断地从任务队列中取出任务，放到调用栈中执行，如此循环往复，让单线程的 JS 也能处理并发操作。 认知重构：单线程 ≠ 一次只能做一件事","frontmatter":{"title":"12.1.1 JS 的心脏——事件循环机制：Call Stack/Event Queue/Callback Queue","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/12-advanced/12.1-event-loop/12.1.1-mechanism.md","filePath":"Advanced-old/12-advanced/12.1-event-loop/12.1.1-mechanism.md","lastUpdated":1766168364000}'),o={name:"Advanced-old/12-advanced/12.1-event-loop/12.1.1-mechanism.md"};function d(c,s,g,A,u,B){const n=p("Mermaid");return i(),r("div",null,[s[2]||(s[2]=t('<h1 id="_12-1-1-js-的心脏——事件循环机制-call-stack-event-queue-callback-queue" tabindex="-1">12.1.1 JS 的心脏——事件循环机制：Call Stack/Event Queue/Callback Queue <a class="header-anchor" href="#_12-1-1-js-的心脏——事件循环机制-call-stack-event-queue-callback-queue" aria-label="Permalink to &quot;12.1.1 JS 的心脏——事件循环机制：Call Stack/Event Queue/Callback Queue&quot;">​</a></h1><h3 id="一句话破题" tabindex="-1">一句话破题 <a class="header-anchor" href="#一句话破题" aria-label="Permalink to &quot;一句话破题&quot;">​</a></h3><p>事件循环是 JavaScript 引擎的&quot;心脏&quot;，它不断地从任务队列中取出任务，放到调用栈中执行，如此循环往复，让单线程的 JS 也能处理并发操作。</p><h3 id="认知重构-单线程-一次只能做一件事" tabindex="-1">认知重构：单线程 ≠ 一次只能做一件事 <a class="header-anchor" href="#认知重构-单线程-一次只能做一件事" aria-label="Permalink to &quot;认知重构：单线程 ≠ 一次只能做一件事&quot;">​</a></h3><p>很多人误以为&quot;单线程&quot;意味着 JavaScript 一次只能处理一件事。实际上，JavaScript <strong>运行时</strong>是单线程的，但它背后有一整套异步机制（由浏览器或 Node.js 提供），让它可以&quot;同时&quot;发起多个操作。</p><p>真正的限制是：<strong>JavaScript 一次只能执行一段代码</strong>。但在执行的间隙，其他操作（如网络请求、定时器）可以在后台进行，完成后再&quot;排队&quot;等待执行。</p><h3 id="本质还原-事件循环的核心组件" tabindex="-1">本质还原：事件循环的核心组件 <a class="header-anchor" href="#本质还原-事件循环的核心组件" aria-label="Permalink to &quot;本质还原：事件循环的核心组件&quot;">​</a></h3>',7)),(i(),l(E,null,{default:a(()=>[h(n,{id:"mermaid-21",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%0A%20%20%20%20%20%20%20%20A%5B%22%E8%B0%83%E7%94%A8%E6%A0%88%20Call%20Stack%22%5D%20%0A%20%20%20%20%20%20%20%20B%5B%22Web%20APIs%20%2F%20Node%20APIs%22%5D%0A%20%20%20%20%20%20%20%20C%5B%22%E5%AE%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%20Macrotask%20Queue%22%5D%0A%20%20%20%20%20%20%20%20D%5B%22%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%20Microtask%20Queue%22%5D%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20E%5B%22%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20Event%20Loop%22%5D%0A%20%20%20%20%0A%20%20%20%20A%20--%3E%7C%22%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%22%7C%20B%0A%20%20%20%20B%20--%3E%7C%22%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C%22%7C%20C%0A%20%20%20%20B%20--%3E%7C%22Promise%20%E5%9B%9E%E8%B0%83%22%7C%20D%0A%20%20%20%20E%20--%3E%7C%22%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%22%7C%20A%0A%20%20%20%20C%20-.-%3E%7C%22%E4%B8%8B%E4%B8%80%E8%BD%AE%22%7C%20E%0A%20%20%20%20D%20-.-%3E%7C%22%E4%BC%98%E5%85%88%E6%89%A7%E8%A1%8C%22%7C%20E%0A"})]),fallback:a(()=>[...s[0]||(s[0]=[e(" Loading... ",-1)])]),_:1})),s[3]||(s[3]=t(`<h4 id="_1-调用栈-call-stack" tabindex="-1">1. 调用栈 (Call Stack) <a class="header-anchor" href="#_1-调用栈-call-stack" aria-label="Permalink to &quot;1. 调用栈 (Call Stack)&quot;">​</a></h4><p>调用栈是一个 LIFO（后进先出）的数据结构，记录当前正在执行的函数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> multiply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> multiply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n, n);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用栈：main → square → multiply → 返回 → 返回 → 输出</span></span></code></pre></div><p><strong>关键点</strong>：如果调用栈中有正在执行的代码，事件循环就会等待，不会取新任务。这就是为什么&quot;同步阻塞代码&quot;会卡死页面。</p><h4 id="_2-宏任务与微任务" tabindex="-1">2. 宏任务与微任务 <a class="header-anchor" href="#_2-宏任务与微任务" aria-label="Permalink to &quot;2. 宏任务与微任务&quot;">​</a></h4><p>异步任务分为两类，它们的执行优先级不同：</p><table tabindex="0"><thead><tr><th>类型</th><th>示例</th><th>优先级</th></tr></thead><tbody><tr><td><strong>微任务 Microtask</strong></td><td><code>Promise.then/catch/finally</code>、<code>queueMicrotask</code>、<code>MutationObserver</code></td><td>高（当前宏任务结束后立即执行）</td></tr><tr><td><strong>宏任务 Macrotask</strong></td><td><code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、I/O 操作、UI 渲染</td><td>低（下一轮事件循环）</td></tr></tbody></table><h4 id="_3-事件循环的执行顺序" tabindex="-1">3. 事件循环的执行顺序 <a class="header-anchor" href="#_3-事件循环的执行顺序" aria-label="Permalink to &quot;3. 事件循环的执行顺序&quot;">​</a></h4>`,8)),(i(),l(E,null,{default:a(()=>[h(n,{id:"mermaid-80",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5B%221.%20%E6%89%A7%E8%A1%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%22%5D%20--%3E%20B%5B%222.%20%E8%B0%83%E7%94%A8%E6%A0%88%E6%B8%85%E7%A9%BA%22%5D%0A%20%20%20%20B%20--%3E%20C%7B%22%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%3F%22%7D%0A%20%20%20%20C%20--%3E%7C%22%E5%90%A6%22%7C%20D%5B%223.%20%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E5%BE%AE%E4%BB%BB%E5%8A%A1%22%5D%0A%20%20%20%20D%20--%3E%20C%0A%20%20%20%20C%20--%3E%7C%22%E6%98%AF%22%7C%20E%5B%224.%20%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%8F%E4%BB%BB%E5%8A%A1%22%5D%0A%20%20%20%20E%20--%3E%20A%0A"})]),fallback:a(()=>[...s[1]||(s[1]=[e(" Loading... ",-1)])]),_:1})),s[4]||(s[4]=t(`<p><strong>黄金法则</strong>：每执行完一个宏任务，都会清空所有微任务，然后才执行下一个宏任务。</p><h3 id="经典面试题-预测输出顺序" tabindex="-1">经典面试题：预测输出顺序 <a class="header-anchor" href="#经典面试题-预测输出顺序" aria-label="Permalink to &quot;经典面试题：预测输出顺序&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 宏任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 微任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步</span></span></code></pre></div><p><strong>输出</strong>：<code>1 → 4 → 3 → 2</code></p><p><strong>分析</strong>：</p><ol><li>同步代码先执行：<code>1</code>、<code>4</code></li><li>调用栈清空，执行微任务队列：<code>3</code></li><li>进入下一轮事件循环，执行宏任务：<code>2</code></li></ol><h3 id="觉知-审查-ai-生成代码的要点" tabindex="-1">觉知：审查 AI 生成代码的要点 <a class="header-anchor" href="#觉知-审查-ai-生成代码的要点" aria-label="Permalink to &quot;觉知：审查 AI 生成代码的要点&quot;">​</a></h3><p>当 AI 帮你写异步代码时，你需要检查：</p><ol><li><strong>执行顺序</strong>：代码的实际执行顺序是否符合业务预期？</li><li><strong>阻塞风险</strong>：是否有大量同步计算阻塞事件循环？</li><li><strong>资源竞争</strong>：多个异步操作是否会竞争同一资源？</li></ol><h3 id="避坑指南" tabindex="-1">避坑指南 <a class="header-anchor" href="#避坑指南" aria-label="Permalink to &quot;避坑指南&quot;">​</a></h3><ul><li><strong>不要在主线程做重计算</strong>：循环百万次的计算会阻塞事件循环，导致页面卡顿。可用 Web Worker 或分片处理。</li><li><strong><code>setTimeout(fn, 0)</code> 不是&quot;立即执行&quot;</strong>：它只是把回调放入宏任务队列，至少要等当前同步代码和所有微任务执行完。</li><li><strong>微任务可以&quot;无限套娃&quot;</strong>：如果在微任务中不断创建新的微任务，会阻塞宏任务，导致 UI 无法响应。</li></ul>`,11))])}const F=k(o,[["render",d]]);export{y as __pageData,F as default};
