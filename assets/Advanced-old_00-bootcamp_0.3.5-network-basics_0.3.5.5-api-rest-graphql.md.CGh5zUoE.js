import{_ as t,C as h,c as r,o as i,a3 as s,b as n,w as e,a as p,G as o,a4 as d}from"./chunks/framework.CUcrqFol.js";const T=JSON.parse('{"title":"0.3.5.5 程序间的通用语言——API 设计基础：RESTful 与 GraphQL 概念","description":"0.3.5.5 程序间的通用语言——API 设计基础：RESTful 与 GraphQL 概念 认知重构：从“接口”到“契约” API 不只是“一个地址加点数据”，而是**客户端与服务端的协作契约**：双方约定资源结构、交互方式与错误语义。主流风格有两种：REST 与 GraphQL。 本质还原：REST 与 Grap","frontmatter":{"title":"0.3.5.5 程序间的通用语言——API 设计基础：RESTful 与 GraphQL 概念","typora-root-url":"../../public"},"headers":[],"relativePath":"Advanced-old/00-bootcamp/0.3.5-network-basics/0.3.5.5-api-rest-graphql.md","filePath":"Advanced-old/00-bootcamp/0.3.5-network-basics/0.3.5.5-api-rest-graphql.md","lastUpdated":1766168364000}'),E={name:"Advanced-old/00-bootcamp/0.3.5-network-basics/0.3.5.5-api-rest-graphql.md"};function c(k,a,u,A,g,B){const l=h("Mermaid");return i(),r("div",null,[a[1]||(a[1]=s('<h1 id="_0-3-5-5-程序间的通用语言——api-设计基础-restful-与-graphql-概念" tabindex="-1">0.3.5.5 程序间的通用语言——API 设计基础：RESTful 与 GraphQL 概念 <a class="header-anchor" href="#_0-3-5-5-程序间的通用语言——api-设计基础-restful-与-graphql-概念" aria-label="Permalink to &quot;0.3.5.5 程序间的通用语言——API 设计基础：RESTful 与 GraphQL 概念&quot;">​</a></h1><h2 id="认知重构-从-接口-到-契约" tabindex="-1">认知重构：从“接口”到“契约” <a class="header-anchor" href="#认知重构-从-接口-到-契约" aria-label="Permalink to &quot;认知重构：从“接口”到“契约”&quot;">​</a></h2><p>API 不只是“一个地址加点数据”，而是<strong>客户端与服务端的协作契约</strong>：双方约定资源结构、交互方式与错误语义。主流风格有两种：REST 与 GraphQL。</p><h2 id="本质还原-rest-与-graphql-的核心差异" tabindex="-1">本质还原：REST 与 GraphQL 的核心差异 <a class="header-anchor" href="#本质还原-rest-与-graphql-的核心差异" aria-label="Permalink to &quot;本质还原：REST 与 GraphQL 的核心差异&quot;">​</a></h2>',4)),(i(),n(d,null,{default:e(()=>[o(l,{id:"mermaid-12",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20subgraph%20sgrest%20%5B%22REST%22%5D%0A%20%20%20%20%20%20%20%20C1%5B%E5%AE%A2%E6%88%B7%E7%AB%AF%5D%20--%3E%20E1%5B%E5%A4%9A%E4%B8%AA%E7%AB%AF%E7%82%B9%20%2Fusers%20%2Fposts%5D%3B%0A%20%20%20%20%20%20%20%20E1%20--%3E%20M1%5B%E7%94%A8%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%8A%A8%E4%BD%9C%20GET%2FPOST%E7%AD%89%5D%3B%0A%20%20%20%20%20%20%20%20M1%20--%3E%20S1%5B%E6%8C%89%E8%B5%84%E6%BA%90%E8%BF%94%E5%9B%9E%E5%9B%BA%E5%AE%9A%E7%BB%93%E6%9E%84%5D%3B%0A%20%20%20%20end%0A%20%20%20%20subgraph%20sgql%20%5B%22GraphQL%22%5D%0A%20%20%20%20%20%20%20%20C2%5B%E5%AE%A2%E6%88%B7%E7%AB%AF%5D%20--%3E%20E2%5B%E5%8D%95%E4%B8%80%E7%AB%AF%E7%82%B9%20%2Fgraphql%5D%3B%0A%20%20%20%20%20%20%20%20E2%20--%3E%20Q2%5B%E6%8C%89%E6%9F%A5%E8%AF%A2%E5%A3%B0%E6%98%8E%E9%9C%80%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5%5D%3B%0A%20%20%20%20%20%20%20%20Q2%20--%3E%20S2%5B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%B2%BE%E7%A1%AE%E6%95%B0%E6%8D%AE%5D%3B%0A%20%20%20%20end%0A"})]),fallback:e(()=>[...a[0]||(a[0]=[p(" Loading... ",-1)])]),_:1})),a[2]||(a[2]=s(`<h3 id="rest-要点" tabindex="-1">REST 要点 <a class="header-anchor" href="#rest-要点" aria-label="Permalink to &quot;REST 要点&quot;">​</a></h3><ul><li>以“资源”为中心：<code>/users</code>, <code>/posts/{id}</code>。</li><li>方法表达语义：读用 <code>GET</code>，写用 <code>POST/PUT/PATCH/DELETE</code>。</li><li>状态码表达结果：<code>200/201/204/4xx/5xx</code>。</li><li>支持缓存：<code>ETag</code>/<code>Cache-Control</code>。</li><li>分页、筛选与排序：<code>?page=1&amp;pageSize=20&amp;sort=createdAt</code>。</li></ul><h3 id="graphql-要点" tabindex="-1">GraphQL 要点 <a class="header-anchor" href="#graphql-要点" aria-label="Permalink to &quot;GraphQL 要点&quot;">​</a></h3><ul><li>单一端点，按查询语句返回所需字段，避免“过多或过少的数据”。</li><li>强类型 Schema 定义数据结构与关系。</li><li>由 Resolver 实现字段级的数据获取。</li><li>支持聚合多个后端源，前端一次拿到所需数据。</li></ul><h2 id="落地与实战-最小闭环示例" tabindex="-1">落地与实战：最小闭环示例 <a class="header-anchor" href="#落地与实战-最小闭环示例" aria-label="Permalink to &quot;落地与实战：最小闭环示例&quot;">​</a></h2><h3 id="需求-mini-prd" tabindex="-1">需求 (Mini-PRD) <a class="header-anchor" href="#需求-mini-prd" aria-label="Permalink to &quot;需求 (Mini-PRD)&quot;">​</a></h3><ul><li>获取用户列表与其文章数。</li><li>前端希望一次请求拿到用户 <code>id/name</code> 与 <code>postCount</code>。</li></ul><h3 id="rest-方案" tabindex="-1">REST 方案 <a class="header-anchor" href="#rest-方案" aria-label="Permalink to &quot;REST 方案&quot;">​</a></h3><ul><li>端点：<code>GET /users</code> 返回用户数组；<code>GET /posts?userId=&lt;id&gt;</code> 获取该用户的文章，再在客户端汇总。</li><li>优点：简单直观；缓存与监控成熟。</li><li>缺点：可能需要多次请求；前端需要汇总逻辑。</li></ul><h3 id="graphql-方案" tabindex="-1">GraphQL 方案 <a class="header-anchor" href="#graphql-方案" aria-label="Permalink to &quot;GraphQL 方案&quot;">​</a></h3><ul><li>查询：</li></ul><div class="language-graphql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">graphql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  users</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    id</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    name</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    postCount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>优点：一次拿齐，需要什么拿什么。</li><li>缺点：服务端需要维护 Schema/Resolver；监控与缓存策略需专门设计。</li></ul><h2 id="验收清单" tabindex="-1">验收清单 <a class="header-anchor" href="#验收清单" aria-label="Permalink to &quot;验收清单&quot;">​</a></h2><ul><li>REST： <ul><li>方法与语义一致；状态码与错误体规范；分页参数与默认值明确。</li><li>返回的 <code>Content-Type</code> 与内容一致；支持合理的缓存策略。</li></ul></li><li>GraphQL： <ul><li>Schema 边界清晰（必填/可选）；错误结构一致；复杂查询有速率限制。</li><li>Resolver 无 N+1 问题（必要时加入数据加载器）。</li></ul></li></ul><h2 id="ai-协作指南" tabindex="-1">AI 协作指南 <a class="header-anchor" href="#ai-协作指南" aria-label="Permalink to &quot;AI 协作指南&quot;">​</a></h2><ul><li>核心意图：让 AI 按“契约”生成接口与验证脚本。</li><li>需求定义公式： <ul><li>“为用户资源设计 REST 接口，返回分页数据，并且提供错误示例与状态码说明。”</li><li>“请提供一个 GraphQL Schema 与对应 Resolver 的雏形，用于查询 <code>users{id,name,postCount}</code>。”</li></ul></li><li>关键术语：<code>资源(REST)</code>, <code>状态码</code>, <code>ETag</code>, <code>Schema</code>, <code>Resolver</code>, <code>N+1</code>。</li><li>Windows PowerShell 调试： <ul><li>REST：<code>Invoke-RestMethod -Method GET -Uri https://api.example.com/users?page=1&amp;pageSize=10</code></li><li>GraphQL：<div class="language-powershell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> @</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ query </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;query { users { id name } }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ConvertTo-Json</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Invoke-RestMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Method POST </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Uri https:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">api.example.com</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graphql </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Body $body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ContentType </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span></span></code></pre></div></li></ul></li></ul><h2 id="决策建议" tabindex="-1">决策建议 <a class="header-anchor" href="#决策建议" aria-label="Permalink to &quot;决策建议&quot;">​</a></h2><ul><li>后端资源清晰、缓存友好、监控成熟的场景选 REST；</li><li>前端组合数据、减少往返、字段可裁剪的场景选 GraphQL；</li><li>大多数产品可采用“REST 为主，关键聚合场景引入 GraphQL”的混合策略。</li></ul>`,19))])}const b=t(E,[["render",c]]);export{T as __pageData,b as default};
