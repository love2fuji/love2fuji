---
title: "3.3.5 Self-Critique：让 AI 自我检查"
---

# 3.3.5 Self-Critique：让 AI 自我检查

## 经过本节学习，你将掌握

- Self-Critique（自我批评）的定义和原理
- 为什么 AI 自查能提升输出质量
- 自查的核心维度清单
- 如何在提示词中引导 AI 自查
- Self-Critique 的局限性

## 什么是 Self-Critique

Self-Critique（自我批评）的核心思想是：**让 AI 生成内容后，再自己检查一遍，发现并修正问题**。

这就像写完文章后自己校对一遍，往往能发现最初遗漏的错误。

```
生成 → 自查 → 修正
```

## 核心洞见：为什么自查有效

> "SELF-REFINE 方法可以在无需额外训练的情况下，将 AI 输出质量提升约 20%。"
> —— 2023 年 CMU 研究论文

这个数据告诉我们：同一个 AI，加一步自查，效果就能明显提升。

原因在于：
1. **第一次生成往往有遗漏**：AI 快速生成时可能忽略边界情况
2. **自查时换个视角**：审查模式会关注不同方面
3. **迭代改进更精准**：基于具体问题修改，比重新生成更准确

## 自查的核心维度

不同类型的内容，需要检查的维度不同：

### 代码自查维度

| 维度 | 检查内容 | 常见问题 |
|-----|---------|---------|
| **功能正确性** | 是否实现了需求 | 遗漏部分功能 |
| **边界情况** | 空值、极值、异常输入 | 没处理 null/undefined |
| **安全性** | XSS、注入、敏感数据 | 用户输入未过滤 |
| **性能** | 时间/空间复杂度 | 不必要的循环嵌套 |
| **可读性** | 命名、注释、结构 | 变量名不清晰 |
| **可维护性** | 重复代码、耦合度 | 硬编码 magic number |

### 文案/文档自查维度

| 维度 | 检查内容 |
|-----|---------|
| **准确性** | 信息是否正确 |
| **完整性** | 是否遗漏关键点 |
| **清晰度** | 是否容易理解 |
| **一致性** | 术语、风格是否统一 |

## 差提示词 vs 好提示词

### 场景：生成表单验证函数

### ❌ 差提示词

```
写一个验证用户注册表单的函数，检查邮箱和密码。
```

AI 可能生成一个基础版本，但遗漏边界情况。

### ✅ 好提示词（带 Self-Critique）

```
写一个验证用户注册表单的函数，检查邮箱和密码。

生成后，请自查：
1. 是否覆盖了所有边界情况（空值、空字符串、只有空格）？
2. 是否有安全隐患（XSS、注入风险）？
3. 错误提示是否清晰，用户能知道具体问题？
4. 是否有不必要的重复代码？

如有问题，请修正后重新输出最终版本。
```

### 好提示词的 AI 输出

AI 会先生成代码，然后逐条检查，最后给出改进版：

```javascript
// 自查发现的问题：
// 1. 原版没有处理 trim 后为空的情况
// 2. 错误提示不够具体
// 3. 邮箱正则可以更严格

// 改进后的版本：
function validateRegistration(email, password) {
  const errors = [];
  
  // 处理空白字符
  const trimmedEmail = email?.trim() || '';
  const trimmedPassword = password || '';
  
  // 邮箱验证
  if (!trimmedEmail) {
    errors.push('邮箱不能为空');
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmedEmail)) {
    errors.push('邮箱格式不正确，请检查是否包含 @ 和域名');
  }
  
  // 密码验证
  if (!trimmedPassword) {
    errors.push('密码不能为空');
  } else {
    if (trimmedPassword.length < 8) {
      errors.push('密码长度至少 8 位');
    }
    if (!/[A-Z]/.test(trimmedPassword)) {
      errors.push('密码需要包含至少一个大写字母');
    }
    if (!/[0-9]/.test(trimmedPassword)) {
      errors.push('密码需要包含至少一个数字');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

## 常用自查指令词库

### 通用自查

```
生成后，请检查是否有遗漏或错误，如有请修正。
```

### 代码自查

```
请自查：
1. 边界情况是否都处理了？
2. 有没有潜在的安全问题？
3. 性能是否可以优化？
如有问题，请修正后输出最终版本。
```

### 严格自查

```
请扮演一个严格的代码审查者，审查你刚才生成的代码：
- 找出至少 3 个可以改进的地方
- 给出改进后的版本
```

### 特定维度自查

```
请从 [安全性/性能/可读性] 角度审查这段代码，指出问题并修正。
```

## 实战示例：待办清单项目

小李让 AI 生成一个任务排序函数，并要求自查。

### Self-Critique 提示词

```
为我的待办清单应用写一个排序函数，支持按以下方式排序：
- 按创建时间（新到旧）
- 按截止日期（近到远，无截止日期的排最后）
- 按优先级（高 > 中 > 低）

任务数据结构：
{
  id: string,
  title: string,
  createdAt: Date,
  dueDate: Date | null,
  priority: 'high' | 'medium' | 'low'
}

生成后，请自查：
1. 排序逻辑是否正确处理了 null/undefined？
2. 优先级排序的顺序是否符合预期？
3. 函数接口是否清晰易用？
如有问题，请修正。
```

### AI 输出（含自查过程）

```javascript
// 初版实现...

// 自查发现：
// 1. dueDate 为 null 时直接比较会出问题 ✓ 已处理
// 2. 优先级用字符串比较不可靠，需要映射为数字 → 需修正
// 3. 函数可以更灵活，支持升序/降序 → 已优化

// 最终版本：
const priorityMap = { high: 3, medium: 2, low: 1 };

function sortTasks(tasks, sortBy, order = 'desc') {
  const direction = order === 'desc' ? -1 : 1;
  
  return [...tasks].sort((a, b) => {
    switch (sortBy) {
      case 'createdAt':
        return direction * (new Date(b.createdAt) - new Date(a.createdAt));
      
      case 'dueDate':
        // null 排最后
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return direction * (new Date(a.dueDate) - new Date(b.dueDate));
      
      case 'priority':
        return direction * (priorityMap[b.priority] - priorityMap[a.priority]);
      
      default:
        return 0;
    }
  });
}
```

## 迭代式 Self-Critique

对于重要输出，可以进行多轮自查：

```
第一轮：功能正确性检查
第二轮：安全性检查
第三轮：性能和代码质量检查
```

每轮聚焦一个维度，逐步完善。

## Self-Critique 的局限性

| 局限 | 表现 | 应对方法 |
|-----|------|---------|
| 自我认可偏差 | AI 可能认为自己的输出没问题 | 用「扮演严格审查者」指令 |
| 检查不彻底 | 可能遗漏某些维度 | 明确列出要检查的维度 |
| 越查越乱 | 修正时引入新问题 | 限制修改范围，一次只改一处 |
| 增加 token | 输出变长 | 对重要输出使用，简单任务跳过 |

## 与人工审查的配合

Self-Critique 不能替代人工审查，而是**减轻人工审查负担**。

推荐流程：
1. AI 生成 + 自查 → 得到初版
2. 你快速浏览，发现明显问题 → 让 AI 修正
3. 最终人工确认关键逻辑

## 可复制模板

### 代码生成 + 自查模板

```markdown
[任务描述]

生成后，请自查：
1. 是否覆盖了所有边界情况？
2. 是否有安全隐患？
3. 代码是否清晰可维护？
如有问题，请修正后输出最终版本。
```

### 严格审查模板

```markdown
请扮演一个严格的 [角色：代码审查者/编辑/QA]，审查你刚才的输出：
- 找出至少 [数量] 个可以改进的地方
- 说明每个问题的影响
- 给出改进后的版本
```

### 特定维度审查模板

```markdown
请从以下维度审查你的输出：
- [ ] [维度1]
- [ ] [维度2]
- [ ] [维度3]

对每个维度，说明是否通过，如不通过请修正。
```

## 本节要点

✓ **Self-Critique 的本质**：让 AI 生成后自我检查，发现并修正问题

✓ **为什么有效**：自查时换视角，能发现第一次遗漏的问题

✓ **核心维度**：功能正确性、边界情况、安全性、性能、可读性

✓ **常用指令**：「请自查...如有问题请修正」「扮演严格审查者」

✓ **局限性**：可能自我认可、检查不彻底，需配合人工审查

下一节，我们学习如何选择合适的技巧——技巧选择指南。
